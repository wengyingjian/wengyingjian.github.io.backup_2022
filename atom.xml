<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>翁英健的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-28T11:37:51.902Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>翁英健</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IDEA 2016 最新版 激活 破解</title>
    <link href="http://yoursite.com/2016/11/28/idea-license/"/>
    <id>http://yoursite.com/2016/11/28/idea-license/</id>
    <published>2016-11-28T10:23:12.000Z</published>
    <updated>2018-10-28T11:37:51.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文"><a href="#文" class="headerlink" title="文"></a>文</h2><p><strong>Activate new license with</strong><br>选择 <strong>License server</strong></p><p>地址填入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://idea.eatbaidu.xyz</span><br></pre></td></tr></table></figure><p>点击<strong>Activate</strong>即可</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p><img src="http://wengyingjian.github.io/images/pages/idea-license/1.jpg" alt="截图"></p><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2016/11/28/idea-license/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/11/28/idea-license/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      IDEA 2016 最新版 激活 破解
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="idea" scheme="http://yoursite.com/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>Nginx－虚拟主机、反向代理、负载均衡</title>
    <link href="http://yoursite.com/2016/03/10/nginx-usage-list/"/>
    <id>http://yoursite.com/2016/03/10/nginx-usage-list/</id>
    <published>2016-03-09T16:37:53.000Z</published>
    <updated>2018-10-28T11:37:51.920Z</updated>
    
    <content type="html"><![CDATA[<p>假定nginx已经安装完了，并且正常运行。  </p><h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>现在我的Nginx是作为Gitlab服务器在使用:<a href="http://gitlab.wengyingjian.com/" target="_blank" rel="noopener">http://gitlab.wengyingjian.com/</a>，我希望在不影响Gitlab正常使用的情况下添加一个文件下载站的功能。  </p><p>即访问<a href="http://download.wengyingjian.com/" target="_blank" rel="noopener">http://download.wengyingjian.com/</a>找到的还是这台Nginx服务器，但且此时提供的功能是文件下载而非Gitlab。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>添加一条<code>server</code>的配置，为<code>server_name</code>是<code>download.wengyingjian.com</code>的请求分配对应的处理方案。  </p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="server配置文件"><a href="#server配置文件" class="headerlink" title="server配置文件"></a>server配置文件</h4><p>新建<code>vhosts</code>文件夹（以后的虚拟主机都存放到此处），添加<code>download</code>模块的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/nginx/vhosts</span><br><span class="line">cd /etc/nginx/vhosts</span><br><span class="line">vim download.wengyingjian.com #文件名随意，此处命名纯粹为了可读性。此文件即server配置文件</span><br></pre></td></tr></table></figure><p><code>download.wengyingjian.com</code>文件中加入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80; #同样监听80端口</span><br><span class="line">        server_name  download.wengyingjian.com; #此处指定server_name，对于请求会进来</span><br><span class="line">        location / &#123;</span><br><span class="line">        #对于download的请求，会去找到/usr/share/nginx/download.wengyingjian.com/文件目录</span><br><span class="line">        root /usr/share/nginx/download.wengyingjian.com; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="root处理目录"><a href="#root处理目录" class="headerlink" title="root处理目录"></a>root处理目录</h4><p>新建root目录，添加下载资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/share/nginx/download.wengyingjian.com</span><br><span class="line">cd /usr/share/nginx/download.wengyingjian.com</span><br><span class="line">#在根目录放置index.html用于测试是否成功</span><br><span class="line">cat &quot;aa&quot; &gt; index.html</span><br></pre></td></tr></table></figure><h4 id="nginx-conf中添加配置"><a href="#nginx-conf中添加配置" class="headerlink" title="nginx.conf中添加配置"></a>nginx.conf中添加配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>在<code>http</code>配置<code>}</code>结束前加入<code>include /etc/nginx/vhosts/*</code></p><h4 id="设置置域名解析，指向nginx所在服务器"><a href="#设置置域名解析，指向nginx所在服务器" class="headerlink" title="设置置域名解析，指向nginx所在服务器"></a>设置置域名解析，指向nginx所在服务器</h4><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>先来4个虚拟主机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 10001;</span><br><span class="line">    server_name 127.0.0.1;</span><br><span class="line">    root /data/www/test/t1;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">    listen 10002;</span><br><span class="line">    server_name 127.0.0.1;</span><br><span class="line">    root /data/www/test/t2;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">    listen 10003;</span><br><span class="line">    server_name 127.0.0.1;</span><br><span class="line">    root /data/www/test/t3;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">    listen 10004;</span><br><span class="line">    server_name 127.0.0.1;</span><br><span class="line">    root /data/www/test/t4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在4个虚拟主机的root目录放好<code>index.html</code>文件，并且写上不同的内容，方便区分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/www/test/t1</span><br><span class="line">mkdir -p /data/www/test/t2</span><br><span class="line">mkdir -p /data/www/test/t3</span><br><span class="line">mkdir -p /data/www/test/t4</span><br><span class="line">echo &quot;1111&quot; &gt; /data/www/test/t1/index.html</span><br><span class="line">echo &quot;2222&quot; &gt; /data/www/test/t2/index.html</span><br><span class="line">echo &quot;3333&quot; &gt; /data/www/test/t3/index.html</span><br><span class="line">echo &quot;4444&quot; &gt; /data/www/test/t4/index.html</span><br></pre></td></tr></table></figure><p>负载均衡</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream test.load_balance &#123;</span><br><span class="line">      server 127.0.0.1:10001;</span><br><span class="line">      server 127.0.0.1:10002;</span><br><span class="line">      server 127.0.0.1:10003;</span><br><span class="line">      server 127.0.0.1:10004;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">    server_name 120.27.97.242;</span><br><span class="line">    root /data/www/test/loadbalance;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://test.load_balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h3><p><a href="http://120.27.97.242" target="_blank" rel="noopener">http://120.27.97.242</a></p><h3 id="负载均衡的分配策略"><a href="#负载均衡的分配策略" class="headerlink" title="负载均衡的分配策略"></a>负载均衡的分配策略</h3><p>。。。</p><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2016/03/10/nginx-usage-list/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/03/10/nginx-usage-list/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      配置Nginx虚拟主机、反向代理、负载均衡服务器案例。
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号开发</title>
    <link href="http://yoursite.com/2016/02/20/wechat-develop/"/>
    <id>http://yoursite.com/2016/02/20/wechat-develop/</id>
    <published>2016-02-20T13:23:56.000Z</published>
    <updated>2018-10-28T11:37:51.947Z</updated>
    
    <content type="html"><![CDATA[<p>最近在搞微信公众（个人订阅）号。<br>虽然功能有限，但是与以往的项目有些不一样，所以决定纪录一下。  </p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>环境需求：一台公网能够访问的服务器、后台开发能力  </p><p>后台用的是springboot项目<br>加上自己的<a href="http://github.com/wengyingjian/kylin" target="_blank" rel="noopener">kylin</a>依赖以及<a href="http://github.com/wengyingjian/kylin" target="_blank" rel="noopener">kylin-archetype</a>脚手架，整个项目搭建起来用了2秒钟左右。。  </p><p>项目地址：<a href="http://github.com/wengyingjian/weixin/" target="_blank" rel="noopener">http://github.com/wengyingjian/weixin/</a></p><h2 id="签名验证"><a href="#签名验证" class="headerlink" title="签名验证"></a>签名验证</h2><p>在启用开发者模式之前需要先进行token校验，如果校验不通过则不让开启。  </p><p>但是在第一次开启了以后，再次开启不用验证。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="Url"><a href="#Url" class="headerlink" title="Url"></a>Url</h4><p>首先是url，必须以http://或https://开头，分别支持80端口和443端口。<br>那就需要Tomcat配置端口号为80，或者是使用Nginx代理。  </p><h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>就是一个校验的符号，这里填啥到时候服务器端逻辑处理的时候能够对上即可。  </p><h4 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h4><p>怕麻烦，所以直接用明文了。  </p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><img src="http://images2015.cnblogs.com/blog/842598/201602/842598-20160220215135561-1889404499.png" alt=""></p><p>填写完信息以后，微信会发送一个get请求到指定的url，带有一些参数，只有当正确返回的时候校验才算通过。</p><p>Controller代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 微信校验</span><br><span class="line"> *</span><br><span class="line"> * @param signature</span><br><span class="line"> * @param timestamp</span><br><span class="line"> * @param nonce</span><br><span class="line"> * @param echostr</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@RequestMapping(name = &quot;call_back&quot;, method = RequestMethod.GET)</span><br><span class="line">public String checkSignature(String signature,//微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。</span><br><span class="line">                             String timestamp,//时间戳</span><br><span class="line">                             String nonce,//随机数</span><br><span class="line">                             String echostr) &#123;//随机字符串</span><br><span class="line">    logger.info(&quot;checkSignature at &#123;&#125;&quot;, timestamp);</span><br><span class="line">    return signatureService.doCheckSignature(signature, timestamp, nonce, echostr) ? echostr : &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 开发者通过检验signature对请求进行校验（下面有校验方式）。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 加密/校验流程如下：</span><br><span class="line"> * 1. 将token、timestamp、nonce三个参数进行字典序排序</span><br><span class="line"> * 2. 将三个参数字符串拼接成一个字符串进行sha1加密</span><br><span class="line"> * 3. 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信</span><br><span class="line"> *</span><br><span class="line"> * @param signature</span><br><span class="line"> * @param timestamp</span><br><span class="line"> * @param nonce</span><br><span class="line"> * @param echostr</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean doCheckSignature(String signature, String timestamp, String nonce, String echostr) &#123;</span><br><span class="line">    String[] strs = &#123;TOKEN, timestamp, nonce&#125;;</span><br><span class="line">    Arrays.sort(strs);</span><br><span class="line">    String newStr = strs[0] + strs[1] + strs[2];</span><br><span class="line">    String sha1 = EncryptUtil.SHA1(newStr);</span><br><span class="line"></span><br><span class="line">    if (sha1.equals(signature)) &#123;</span><br><span class="line">        logger.info(&quot;check signature success !&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(&quot;check signature failed !&quot;);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接收并回复文本信息"><a href="#接收并回复文本信息" class="headerlink" title="接收并回复文本信息"></a>接收并回复文本信息</h2><h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><p>自己开发应用的时候，一般都是一个业务逻辑对应一个controller方法。<br>但是微信这个不同，我们需要并且只能填写一个url供微信回调，所以所有的业务都是往这个Controller里面走的。  </p><p>签名校验走的是Get请求，其它消息走的是Post请求。  </p><p>所以Controller这么写的：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 接收(并回复)消息</span><br><span class="line"> *</span><br><span class="line"> * @param request</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@RequestMapping(name = &quot;call_back&quot;, method = RequestMethod.POST)</span><br><span class="line">public String receiveMessage(HttpServletRequest request) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从Post请求中获取到消息"><a href="#从Post请求中获取到消息" class="headerlink" title="从Post请求中获取到消息"></a>从Post请求中获取到消息</h3><p>这个请求是不带参数的，所以需要从<code>request</code>的<code>inputStream</code>中去读。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public String read(HttpServletRequest request) &#123;</span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        StringBuffer buffer = new StringBuffer();</span><br><span class="line">        try &#123;</span><br><span class="line">            in = new BufferedReader(new InputStreamReader(request.getInputStream()));</span><br><span class="line">            String line = null;</span><br><span class="line">            while ((line = in.readLine()) != null) &#123;</span><br><span class="line">                buffer.append(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(&quot;request post message parse error:&#123;&#125;&quot;, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return buffer.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="将获取到的消息进行解析"><a href="#将获取到的消息进行解析" class="headerlink" title="将获取到的消息进行解析"></a>将获取到的消息进行解析</h3><p>微信发送过来的消息是XML格式的，而且对于不同的消息类型，格式有所都是不一样的。  </p><p>比如文本消息，格式如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;xml&gt;</span><br><span class="line"> &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;</span><br><span class="line"> &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt; </span><br><span class="line"> &lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;</span><br><span class="line"> &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;</span><br><span class="line"> &lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt;</span><br><span class="line"> &lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;</span><br><span class="line"> &lt;/xml&gt;</span><br></pre></td></tr></table></figure><p>为了确定是文本消息，可以取<code>MsgType</code>为<code>text</code>的。  </p><p>获取<code>MsgType</code>标签内容我这里用的是Xpath，将Xml内容转化为Java对象用的是Xstream。  </p><h3 id="对消息进行回复"><a href="#对消息进行回复" class="headerlink" title="对消息进行回复"></a>对消息进行回复</h3><p>准备好需要回复的内容，然后转化成Xml格式即可。这里还是先init出一个Java对象，然后利用XStream转化为Xml文本。  </p><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2016/02/20/wechat-develop/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/02/20/wechat-develop/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      使用Java作为订阅号后端来处理业务逻辑
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 Gitlab 环境搭建</title>
    <link href="http://yoursite.com/2016/02/08/server-gitlab-init/"/>
    <id>http://yoursite.com/2016/02/08/server-gitlab-init/</id>
    <published>2016-02-08T10:31:48.000Z</published>
    <updated>2018-10-28T11:37:51.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置ssh免密码登录"><a href="#配置ssh免密码登录" class="headerlink" title="配置ssh免密码登录"></a>配置ssh免密码登录</h2><p>（新买的服务器）一直输密码麻烦。   </p><h3 id="客户机"><a href="#客户机" class="headerlink" title="客户机"></a>客户机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa #生成公钥</span><br><span class="line">scp ~/.ssh/id_rsa.pub root@host:. #公钥拷贝至服务器</span><br></pre></td></tr></table></figure><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.ssh</span><br><span class="line">cat ~/id_rsa.pub &gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h2 id="yum源设置"><a href="#yum源设置" class="headerlink" title="yum源设置"></a>yum源设置</h2><p>为了提高安装速度，设置为阿里云开源镜像  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure><h2 id="必要软件包"><a href="#必要软件包" class="headerlink" title="必要软件包"></a>必要软件包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install libicu-devel patch gcc-c++ readline-devel zlib-devel libffi-devel openssl-devel make autoconf automake libtool bison libxml2-devel libxslt-devel libyaml-devel zlib-devel openssl-devel cpio expat-devel gettext-devel curl-devel perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker</span><br></pre></td></tr></table></figure><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="检查版本"><a href="#检查版本" class="headerlink" title="检查版本"></a>检查版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>小于1.7.10则升级  </p><h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove git</span><br></pre></td></tr></table></figure><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /tmp/soft/git &amp;&amp; cd /tmp/soft/git</span><br><span class="line">wget -O git-src.zip https://github.com/git/git/archive/master.zip</span><br><span class="line">unzip git-src.zip</span><br><span class="line">cd git-src</span><br><span class="line">make prefix=/usr/local all</span><br><span class="line">make prefix=/usr/local install</span><br><span class="line">ln -fs /usr/local/bin/git* /usr/bin/</span><br></pre></td></tr></table></figure><h2 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h2><h3 id="下载安装："><a href="#下载安装：" class="headerlink" title="下载安装："></a>下载安装：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /tmp/soft/ruby &amp;&amp; cd /tmp/soft/ruby</span><br><span class="line">curl --progress ftp://ftp.ruby-lang.org/pub/ruby/ruby-2.1.5.tar.gz | tar xz</span><br><span class="line">cd ruby-2.1.5</span><br><span class="line">./configure --disable-install-rdoc</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/bin/ruby /usr/bin/ruby</span><br><span class="line">ln -s /usr/local/bin/gem /usr/bin/gem</span><br><span class="line">ln -s /usr/local/bin/bundle /usr/bin/bundle</span><br><span class="line"></span><br><span class="line">gem source -r https://rubygems.org/ #设置ruby gem源为淘宝</span><br><span class="line">gem source -a https://ruby.taobao.org/</span><br><span class="line">gem install bundler --no-ri --no-rdoc</span><br></pre></td></tr></table></figure><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>1.检查mariadb包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep mariadb</span><br></pre></td></tr></table></figure><p>2.卸载mariadb</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps mariadb-*</span><br></pre></td></tr></table></figure><p>3.安装mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /tmp/soft/mysql &amp;&amp; cd /tmp/soft/mysql</span><br><span class="line"></span><br><span class="line">wget http://dev.mysql.com/get/Downloads/MySQL-5.6/MySQL-5.6.21-1.el7.x86_64.rpm-bundle.tar</span><br><span class="line">tar -xvf MySQL-5.6.21-1.el7.x86_64.rpm-bundle.tar</span><br><span class="line">rpm -ivh MySQL-server-5.6.21-1.el7.x86_64.rpm #password&gt; cat /root/.mysql_secret</span><br><span class="line">rpm -ivh MySQL-shared-5.6.21-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh MySQL-client-5.6.21-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh MySQL-devel-5.6.21-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>4.启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql start</span><br></pre></td></tr></table></figure><p>5.修改root密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set password = PASSWORD(&apos;root&apos;);</span><br></pre></td></tr></table></figure><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE USER &apos;gitlab&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;gitlab&apos;;</span><br><span class="line">mysql&gt; CREATE DATABASE IF NOT EXISTS `gitlabhq_production` DEFAULT CHARACTER SET `utf8` COLLATE `utf8_unicode_ci`;</span><br><span class="line">mysql&gt; GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER ON `gitlabhq_production`.* TO &apos;gitlab&apos;@&apos;localhost&apos;;</span><br></pre></td></tr></table></figure><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install redis</span><br></pre></td></tr></table></figure><p>设置后台开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/redis.conf</span><br><span class="line">#修改以下</span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#/etc/init.d/redis start</span><br><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure><h2 id="添加用户git"><a href="#添加用户git" class="headerlink" title="添加用户git"></a>添加用户git</h2><h3 id="添加用户-sudo"><a href="#添加用户-sudo" class="headerlink" title="添加用户+sudo"></a>添加用户+sudo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd --comment &apos;GitLab&apos; git</span><br><span class="line">echo &quot;git ALL=(ALL)       NOPASSWD: ALL&quot; &gt;&gt;/etc/sudoers</span><br></pre></td></tr></table></figure><h3 id="sudo添加-usr-local-bin"><a href="#sudo添加-usr-local-bin" class="headerlink" title="sudo添加/usr/local/bin"></a>sudo添加/usr/local/bin</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">visudo </span><br><span class="line">#修改以下文件内容</span><br><span class="line">Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin</span><br></pre></td></tr></table></figure><h2 id="Gitlab"><a href="#Gitlab" class="headerlink" title="Gitlab"></a>Gitlab</h2><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /home/git</span><br><span class="line">sudo -u git -H git clone https://gitlab.com/gitlab-org/gitlab-ce.git -b 7-8-stable gitlab</span><br><span class="line">cd /home/git/gitlab</span><br><span class="line">sudo -u git -H cp config/gitlab.yml.example config/gitlab.yml</span><br></pre></td></tr></table></figure><p>编辑git路径, gitlab的host:port</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ vim config/gitlab.yml</span><br><span class="line">// bin_path: /usr/local/bin/git</span><br><span class="line">// host: localhost</span><br><span class="line">// port: 80 </span><br><span class="line"></span><br><span class="line">//email_from :_your_email_ #与git config一致</span><br></pre></td></tr></table></figure><p>// 给文件夹添加相应的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ chown -R git log/</span><br><span class="line">$ chown -R git tmp/</span><br><span class="line">$ chmod -R u+rwx  log/</span><br><span class="line">$ chmod -R u+rwx  tmp/</span><br></pre></td></tr></table></figure><p>// 创建必要的文件夹，以及复制配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -u git -H mkdir /home/git/gitlab-satellites</span><br><span class="line">$ sudo chmod u+rwx,g=rx,o-rwx /home/git/gitlab-satellites</span><br><span class="line">$ sudo -u git -H mkdir tmp/pids/</span><br><span class="line">$ sudo -u git -H mkdir tmp/sockets/</span><br><span class="line">$ sudo -u git -H mkdir public/uploads</span><br><span class="line">$ sudo chmod -R u+rwX  tmp/pids/</span><br><span class="line">$ sudo chmod -R u+rwX  tmp/sockets/</span><br><span class="line">$ sudo chmod -R u+rwX  public/uploads</span><br><span class="line">$ sudo -u git -H cp config/unicorn.rb.example config/unicorn.rb</span><br><span class="line">$ sudo -u git -H cp config/initializers/rack_attack.rb.example config/initializers/rack_attack.rb</span><br></pre></td></tr></table></figure><p>// 配置数据库连接信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -u git cp config/database.yml.mysql config/database.yml</span><br><span class="line">$ sudo -u git -H vim  config/database.yml</span><br><span class="line">$ vim config/database.yml</span><br><span class="line">// production:</span><br><span class="line">//     username: gitlab</span><br><span class="line">//     password: &quot;gitlab&quot;</span><br></pre></td></tr></table></figure><h2 id="GitLab-Shell"><a href="#GitLab-Shell" class="headerlink" title="GitLab-Shell"></a>GitLab-Shell</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /home/git</span><br><span class="line">sudo -u git -H git clone https://gitlab.com/gitlab-org/gitlab-shell.git -b v2.6.0</span><br><span class="line">cd gitlab-shell/</span><br><span class="line">sudo -u git -H cp config.yml.example config.yml</span><br></pre></td></tr></table></figure><p>// 编辑配置文件, 设置gitlab_url, redis-cli, log-level…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim config.yml</span><br><span class="line">// gitlab_url: &quot;http://localhost/&quot;</span><br><span class="line">// /usr/bin/redis-cli   #指定redis的redis-cli 目录</span><br></pre></td></tr></table></figure><p>// 安装git-shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u git -H ./bin/install</span><br></pre></td></tr></table></figure><h2 id="安装需要ruby的gems"><a href="#安装需要ruby的gems" class="headerlink" title="安装需要ruby的gems"></a>安装需要ruby的gems</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/git/gitlab</span><br><span class="line"># 先修改当前目录下的  Gemfile 文件</span><br><span class="line">$ vim Gemfile   source &apos;https://ruby.taobao.org/&apos;    #将源指向到淘宝的源</span><br><span class="line"> # 不修改源是不能执行成功的。</span><br><span class="line"></span><br><span class="line">$ sudo -u git -H bundle install --deployment --without development test postgres aws</span><br><span class="line"></span><br><span class="line">如果上边命令出现如下错误：</span><br><span class="line">Gem::Ext::BuildError: ERROR: Failed to build gem native extension.</span><br><span class="line"></span><br><span class="line">    /usr/local/bin/ruby extconf.rb</span><br><span class="line">checking for cmake... no</span><br><span class="line">ERROR: CMake is required to build Rugged.</span><br><span class="line">*** extconf.rb failed ***</span><br><span class="line">Could not create Makefile due to some reason, probably lack of necessary</span><br><span class="line">libraries and/or headers.  Check the mkmf.log file for more details.  You may</span><br><span class="line">need configuration options.</span><br><span class="line"></span><br><span class="line">Provided configuration options:</span><br><span class="line">--with-opt-dir</span><br><span class="line">--without-opt-dir</span><br><span class="line">--with-opt-include</span><br><span class="line">--without-opt-include=$&#123;opt-dir&#125;/include</span><br><span class="line">--with-opt-lib</span><br><span class="line">--without-opt-lib=$&#123;opt-dir&#125;/lib</span><br><span class="line">--with-make-prog</span><br><span class="line">--without-make-prog</span><br><span class="line">--srcdir=.</span><br><span class="line">--curdir</span><br><span class="line">--ruby=/usr/local/bin/ruby</span><br><span class="line"></span><br><span class="line">extconf failed, exit code 1</span><br><span class="line"></span><br><span class="line">Gem files will remain installed in /home/git/gitlab/vendor/bundle/ruby/2.1.0/gems/rugged-0.21.2 for inspection.</span><br><span class="line">Results logged to /home/git/gitlab/vendor/bundle/ruby/2.1.0/extensions/x86_64-linux/2.1.0-static/rugged-0.21.2/gem_make.out</span><br><span class="line">An error occurred while installing rugged (0.21.2), and Bundler cannot continue.</span><br><span class="line">Make sure that `gem install rugged -v &apos;0.21.2&apos;` succeeds before bundling.</span><br><span class="line"></span><br><span class="line">有以上错误时：执行命令：</span><br><span class="line">$ yum install -y cmake</span><br></pre></td></tr></table></figure><p>初始化数据库(创建GitLab相关表)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -u git -H bundle exec rake gitlab:setup RAILS_ENV=production</span><br></pre></td></tr></table></figure><h2 id="安装启动文件以及日志切割文件"><a href="#安装启动文件以及日志切割文件" class="headerlink" title="安装启动文件以及日志切割文件"></a>安装启动文件以及日志切割文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp lib/support/init.d/gitlab /etc/init.d/gitlab</span><br><span class="line">cp lib/support/init.d/gitlab.default.example /etc/default/gitlab</span><br><span class="line">cp lib/support/logrotate/gitlab /etc/logrotate.d/gitlab</span><br></pre></td></tr></table></figure><h2 id="设置git帐号信息–全局用户和邮件"><a href="#设置git帐号信息–全局用户和邮件" class="headerlink" title="设置git帐号信息–全局用户和邮件"></a>设置git帐号信息–全局用户和邮件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -u git -H git config --global user.name &quot;GitLab&quot;</span><br><span class="line">##### email与config/gitlab.yml中的一致</span><br><span class="line">$ sudo -u git -H git config --global user.email &quot;example@example.com&quot; </span><br><span class="line">$ sudo -u git -H git config --global core.autocrlf input</span><br></pre></td></tr></table></figure><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install nginx</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/nginx/nginx.conf</span><br><span class="line">user              root git;</span><br><span class="line">worker_processes  2;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;&apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;&apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"># GITLAB# Maintainer: @randx# App Version: 5.0</span><br><span class="line"></span><br><span class="line">upstream gitlab &#123;</span><br><span class="line">  server unix:/home/git/gitlab/tmp/sockets/gitlab.socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen *:80 default_server;         # e.g., listen 192.168.1.1:80; In most cases *:80 is a good idea</span><br><span class="line">  server_name YOUR_SERVER_FQDN;     # e.g., server_name source.example.com;</span><br><span class="line">  server_tokens off;     # don&apos;t show the version number, a security best practice</span><br><span class="line">  root /home/git/gitlab/public;</span><br><span class="line"></span><br><span class="line">  # Set value of client_max_body_size to at least the value of git.max_size in gitlab.yml</span><br><span class="line">  client_max_body_size 5m;</span><br><span class="line"></span><br><span class="line">  # individual nginx logs for this gitlab vhost</span><br><span class="line">  access_log  /var/log/nginx/gitlab_access.log;  #必须有/var/log/nginx/</span><br><span class="line">  error_log   /var/log/nginx/gitlab_error.log;   #必须有/var/log/nginx/</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    # serve static files from defined root folder;.# @gitlab is a named location for the upstream fallback, see below</span><br><span class="line">    try_files $uri$uri/index.html $uri.html @gitlab;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # if a file, which is not found in the root folder is requested,# then the proxy pass the request to the upsteam (gitlab unicorn)</span><br><span class="line">  location @gitlab &#123;</span><br><span class="line">    proxy_read_timeout 300; # https://github.com/gitlabhq/gitlabhq/issues/694</span><br><span class="line">    proxy_connect_timeout 300; # https://github.com/gitlabhq/gitlabhq/issues/694</span><br><span class="line">    proxy_redirect     off;</span><br><span class="line"></span><br><span class="line">    proxy_set_header   X-Forwarded-Proto $scheme;</span><br><span class="line">    proxy_set_header   Host              $http_host;</span><br><span class="line">    proxy_set_header   X-Real-IP         $remote_addr;</span><br><span class="line">    proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">    proxy_pass http://localhost:8080;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更改权限，启动nginx"><a href="#更改权限，启动nginx" class="headerlink" title="更改权限，启动nginx"></a>更改权限，启动nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -t   #检查配置文件是否正常</span><br><span class="line">$ chown -R git:git /var/log/nginx/   #文件文件目录权限</span><br><span class="line">$ nginx</span><br></pre></td></tr></table></figure><h2 id="启动Gitlab"><a href="#启动Gitlab" class="headerlink" title="启动Gitlab"></a>启动Gitlab</h2><h3 id="下载服务脚本"><a href="#下载服务脚本" class="headerlink" title="下载服务脚本"></a>下载服务脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget -O /etc/init.d/gitlab  https://gitlab.com/gitlab-org/gitlab-recipes/raw/master/init/sysvinit/centos/gitlab-unicorn</span><br><span class="line">$ chmod +x /etc/init.d/gitlab</span><br><span class="line">$ chkconfig --add gitlab</span><br><span class="line">$ chkconfig gitlab on</span><br></pre></td></tr></table></figure><h3 id="检测当前环境"><a href="#检测当前环境" class="headerlink" title="检测当前环境"></a>检测当前环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/git/gitlab</span><br><span class="line">$ sudo -u git -H bundle exec rake gitlab:env:info RAILS_ENV=production</span><br></pre></td></tr></table></figure><h3 id="拉取gitlab静态资源文件"><a href="#拉取gitlab静态资源文件" class="headerlink" title="拉取gitlab静态资源文件"></a>拉取gitlab静态资源文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -u git -H bundle exec rake assets:precompile RAILS_ENV=production</span><br></pre></td></tr></table></figure><h3 id="启动gitlab"><a href="#启动gitlab" class="headerlink" title="启动gitlab"></a>启动gitlab</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/gitlab start</span><br></pre></td></tr></table></figure><h3 id="检测各个组件是否正常工作"><a href="#检测各个组件是否正常工作" class="headerlink" title="检测各个组件是否正常工作"></a>检测各个组件是否正常工作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -u git -H bundle exec rake gitlab:check RAILS_ENV=production</span><br></pre></td></tr></table></figure><h2 id="登录Gitlab"><a href="#登录Gitlab" class="headerlink" title="登录Gitlab"></a>登录Gitlab</h2><p>用户名：<code>root</code><br>密码：<code>5iveL!fe</code></p><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2016/02/08/server-gitlab-init/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/02/08/server-gitlab-init/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      Centos7 Gitlab 环境搭建
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码（一）－读取xml配置</title>
    <link href="http://yoursite.com/2016/02/06/spring-source-load-xml/"/>
    <id>http://yoursite.com/2016/02/06/spring-source-load-xml/</id>
    <published>2016-02-06T07:33:55.000Z</published>
    <updated>2018-10-28T11:37:51.944Z</updated>
    
    <content type="html"><![CDATA[<p>分析以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;beanFactoryTest.xml&quot;));</span><br></pre></td></tr></table></figure><h3 id="预知"><a href="#预知" class="headerlink" title="预知"></a>预知</h3><ol><li>封装配置文件  </li><li>加载、解析配置文件</li><li>注册beanDefinition </li></ol><h3 id="封装配置文件"><a href="#封装配置文件" class="headerlink" title="封装配置文件"></a>封装配置文件</h3><h4 id="贴代码"><a href="#贴代码" class="headerlink" title="贴代码"></a>贴代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new ClassPathResource(&quot;beanFactoryTest.xml&quot;)</span><br></pre></td></tr></table></figure><h4 id="Resource接口说明"><a href="#Resource接口说明" class="headerlink" title="Resource接口说明"></a>Resource接口说明</h4><p>Resource接口封装了一些资源文件的信息。  </p><p><img src="http://images2015.cnblogs.com/blog/842598/201602/842598-20160206154752929-15787757.png" alt=""><br>通过提供的方法就能够知道到这个接口的作用。  </p><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><p>此处用的是<code>ClassPathResource</code>类，<code>Resource</code>接口的实现类。  </p><p>构造方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ClassPathResource(String path, ClassLoader classLoader) &#123;</span><br><span class="line">Assert.notNull(path, &quot;Path must not be null&quot;);</span><br><span class="line">String pathToUse = StringUtils.cleanPath(path);</span><br><span class="line">if (pathToUse.startsWith(&quot;/&quot;)) &#123;</span><br><span class="line">pathToUse = pathToUse.substring(1);</span><br><span class="line">&#125;</span><br><span class="line">this.path = pathToUse;</span><br><span class="line">this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，就是将资源文件封装成了一个<code>ClassPathResource</code>对象。</p><h3 id="加载配置文件-XmlBeanDefinitionReader"><a href="#加载配置文件-XmlBeanDefinitionReader" class="headerlink" title="加载配置文件:XmlBeanDefinitionReader"></a>加载配置文件:XmlBeanDefinitionReader</h3><h4 id="加载beanDefinition"><a href="#加载beanDefinition" class="headerlink" title="加载beanDefinition"></a>加载beanDefinition</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">...</span><br><span class="line">//Set&lt;EncodedResource&gt;存在于当前类的threadLocal之中</span><br><span class="line">Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">if (currentResources == null) &#123;</span><br><span class="line">currentResources = new HashSet&lt;EncodedResource&gt;(4);</span><br><span class="line">this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">&#125;</span><br><span class="line">if (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">throw new BeanDefinitionStoreException(</span><br><span class="line">&quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">//读取resource的inputstream</span><br><span class="line">InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">try &#123;</span><br><span class="line">//org.xml.sax.InputSource</span><br><span class="line">InputSource inputSource = new InputSource(inputStream);</span><br><span class="line">if (encodedResource.getEncoding() != null) &#123;</span><br><span class="line">inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">&#125;</span><br><span class="line">//读取实现方法</span><br><span class="line">//TODO</span><br><span class="line">return doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException ex) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将<code>encodedResource</code>放入到<code>threadLocal</code>之中</li><li>将资源再次转换，变成<code>inputSource</code>对象，把最终的解析工作委托给<code>doLoadBeanDefinitions</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)</span><br><span class="line">throws BeanDefinitionStoreException &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//加载XML文件，并得到对应的Document(获取对XMl文件的验证模式)</span><br><span class="line">//最终通过DefaultDocumentLoader的loadDocument方法实现</span><br><span class="line">Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">//根据返回Document注册Bean信息//TODO</span><br><span class="line">return registerBeanDefinitions(doc, resource);</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure><ol><li>对资源再一次封装，变成<code>Document</code>对象</li><li>注册<code>BeanDefinition</code></li></ol><h4 id="注册beanDefinition"><a href="#注册beanDefinition" class="headerlink" title="注册beanDefinition"></a>注册beanDefinition</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">//1.实例化BeanDefinitionDocumentReader，使用DefaultBeanDefinitionDocumentReader BeanDefinitionDocumentReader</span><br><span class="line">BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line"></span><br><span class="line">//2.记录注册bean的数量</span><br><span class="line">int countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line"></span><br><span class="line">//3.注册bean</span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line"></span><br><span class="line">//4.计算此次注册了多少个新的bean，并返回</span><br><span class="line">return getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册bean的过程委托给了<code>DefaultBeanDefinitionDocumentReader.registerBeanDefinitions()</code>实现。</p><h3 id="注册BeanDefinition"><a href="#注册BeanDefinition" class="headerlink" title="注册BeanDefinition:"></a>注册BeanDefinition:</h3><h4 id="DefaultBeanDefinitionDocumentReader"><a href="#DefaultBeanDefinitionDocumentReader" class="headerlink" title="DefaultBeanDefinitionDocumentReader"></a>DefaultBeanDefinitionDocumentReader</h4><h5 id="默认标签与自定义标签"><a href="#默认标签与自定义标签" class="headerlink" title="默认标签与自定义标签"></a>默认标签与自定义标签</h5><p>省去中间的一些判断以及预留的接口，最最后来到主要的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">//对beans的处理</span><br><span class="line">//1.对默认的bean声明进行读取和解析</span><br><span class="line">//&lt;bean id= &quot;test&quot; class=&quot;test.TestBean&quot;/&gt;</span><br><span class="line"></span><br><span class="line">//delegate.isDefaultNamespace(root) --&gt;</span><br><span class="line">//--&gt; node.getNamespaceURI与固定命名空间&quot;http://www.springframework.org/schema/beans&quot;对比</span><br><span class="line">//--&gt; 一致＝默认 --&gt; true</span><br><span class="line">if (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">NodeList nl = root.getChildNodes();</span><br><span class="line">for (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line">if (node instanceof Element) &#123;</span><br><span class="line">Element ele = (Element) node;</span><br><span class="line">if (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">//3.默认标签的解析</span><br><span class="line">//对bean的处理//TODO</span><br><span class="line">parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">//4.自定义标签的解析</span><br><span class="line">//对bean的处理</span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//2.对自定义的beans进行解析</span><br><span class="line">//&lt;tx:annotation-driven/&gt;</span><br><span class="line">else &#123;</span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认标签的解析"><a href="#默认标签的解析" class="headerlink" title="默认标签的解析"></a>默认标签的解析</h5><p>这里继续深入默认标签的解析：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line"></span><br><span class="line">//&quot;import&quot;</span><br><span class="line">if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">//TODO:3.3</span><br><span class="line">importBeanDefinitionResource(ele);</span><br><span class="line">&#125;</span><br><span class="line">//&quot;alias&quot;</span><br><span class="line">else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">//TODO:3.2</span><br><span class="line">processAliasRegistration(ele);</span><br><span class="line">&#125;</span><br><span class="line">//&quot;bean&quot;</span><br><span class="line">else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">//TODO:3.1</span><br><span class="line">processBeanDefinition(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line">//&quot;beans&quot;</span><br><span class="line">else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">// recurse</span><br><span class="line">//TODO:3.4：与单独的配置文件并没有太大的差别，无非是递归调用beans的解析过程。</span><br><span class="line">doRegisterBeanDefinitions(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择<code>bean</code>的实现继续跟踪：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">//1.委托BeanDefinitionParserDelegate类的parseBeanDefinitionElement方法进行元素解析，</span><br><span class="line">//返回BeanDefinitionHolder类型的实例bdHolder,</span><br><span class="line">//经过这个方法后，bdHolder实例已经包含我们配置文件中配置的各种属性了，例如class,name,id,alias之类的属性//TODO</span><br><span class="line">BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">//2.当返回的bdHolder不为空(期间无error)的情况下</span><br><span class="line">//若存在默认标签的子节点下再有自定义属性，还需要再次对自定义标签进行解析</span><br><span class="line">if (bdHolder != null) &#123;</span><br><span class="line">/**</span><br><span class="line"> * 在descorateBeanDefinitionIfRequired中看到默认的标签是直接略过的（因为已经解析过了），</span><br><span class="line"> * 这里只对 自定义的标签活着说对bean的自定义属性感兴趣。&lt;br/&gt;</span><br><span class="line"> * 在方法中实现了寻找自定义标签并根据自定义标签寻找命名空间处理器，并进一步的解析。</span><br><span class="line"> */</span><br><span class="line">//-3.1.3如果需要的话，对beanDefinition进行装饰，适用：</span><br><span class="line">// &lt;bean id=&quot;test&quot; class=&quot;test.MyClass&quot;&gt;</span><br><span class="line">//   &lt;mybean:user username=&quot;aaa&quot;/&gt;</span><br><span class="line">// &lt;/bean&gt;</span><br><span class="line">//TODO</span><br><span class="line">bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">try &#123;</span><br><span class="line">// Register the final decorated instance.</span><br><span class="line">//3.解析完成后，需要对解析后的bdHolder进行注册，</span><br><span class="line">//同样，注册操作委托给了BeanDefinitionReaderUtils的registerBeanDefinition方法。</span><br><span class="line">//TODO</span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">&#125;</span><br><span class="line">catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; +</span><br><span class="line">bdHolder.getBeanName() + &quot;&apos;&quot;, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line">// Send registration event.</span><br><span class="line">//4.最后发出响应事件，通知相关的监听器，这个bean已经加载完成了</span><br><span class="line">//3.1.5通知监听器解析及注册完成.</span><br><span class="line">//这里的实现只为扩展，当程序开发人员需要对注册beanDefinition事件进行监听时可以通过注册监听器的方式并将处理逻辑写入监听器中，目前在Sping中并没有对此事件做任何逻辑处理。</span><br><span class="line">getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟踪<code>BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry())</code></p><h4 id="BeanDefinitionReaderUtils"><a href="#BeanDefinitionReaderUtils" class="headerlink" title="BeanDefinitionReaderUtils"></a>BeanDefinitionReaderUtils</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void registerBeanDefinition(</span><br><span class="line">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br><span class="line">throws BeanDefinitionStoreException &#123;</span><br><span class="line">//使用beanName做唯一标识注册</span><br><span class="line">// Register bean definition under primary name.</span><br><span class="line">String beanName = definitionHolder.getBeanName();</span><br><span class="line">//1.通过beanName注册</span><br><span class="line">//TODO-&gt;DefaultListableBeanFactory</span><br><span class="line">registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">//注册所有的别名</span><br><span class="line">// Register aliases for bean name, if any.</span><br><span class="line">String[] aliases = definitionHolder.getAliases();</span><br><span class="line">if (aliases != null) &#123;</span><br><span class="line">for (String alias : aliases) &#123;</span><br><span class="line">//2.通过别名注册beanDefinition</span><br><span class="line">//TODO--&gt;SimpleAliasRegistry</span><br><span class="line">registry.registerAlias(beanName, alias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析的beanDefinition都会被注册到BeanDefnitionRegistry类型的实例registry中，而对于beanDefinition的注册分为了两部分：通过beanName的注册以及通过别名的注册。</p><p>继续：<code>registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</code>–&gt;<code>DefaultListableBeanFactory</code></p><h4 id="DefaultListableBeanDefinition"><a href="#DefaultListableBeanDefinition" class="headerlink" title="DefaultListableBeanDefinition"></a>DefaultListableBeanDefinition</h4><ol><li>对AbstractBeanDefinition的校验。针对于MethodOverrides</li><li>对beanName已经注册的情况的处理。如果是指明为不可覆盖的，则抛异常</li><li>加入map缓存</li><li>清除解析之前列下的对应beanName的缓存</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class="line">throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);</span><br><span class="line">Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);</span><br><span class="line"></span><br><span class="line">if (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">/**</span><br><span class="line"> * 注册前的最后一次校验，这里的校验不同于前面的xml校验。&lt;br/&gt;</span><br><span class="line"> * 主要是对于AbstractBeanDefinition属性中的methodOverrides校验&lt;br/&gt;</span><br><span class="line"> * 校验methodOverrides是否与工厂方法并存或者methodOverrides对于的方法根本不存在</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">&#125;</span><br><span class="line">catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">&quot;Validation of bean definition failed&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">oldBeanDefinition = this.beanDefinitionMap.get(beanName);</span><br><span class="line">//1.处理已经注册的beanName情况</span><br><span class="line">if (oldBeanDefinition != null) &#123;</span><br><span class="line">//如果beanName已经被注册了而且在配置中设置了不可覆盖，则抛出异常</span><br><span class="line">if (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">&quot;Cannot register bean definition [&quot; + beanDefinition + &quot;] for bean &apos;&quot; + beanName +</span><br><span class="line">&quot;&apos;: There is already [&quot; + oldBeanDefinition + &quot;] bound.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//比较老/新bean的优先级，给出提示</span><br><span class="line">else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">else if (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line">//2.再处理未注册bean的情况</span><br><span class="line">else &#123;</span><br><span class="line">//如果bean已经在构建中了</span><br><span class="line">if (hasBeanCreationStarted()) &#123;</span><br><span class="line">// Cannot modify startup-time collection elements anymore (for stable iteration)</span><br><span class="line">synchronized (this.beanDefinitionMap) &#123;</span><br><span class="line">this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1);</span><br><span class="line">updatedDefinitions.addAll(this.beanDefinitionNames);</span><br><span class="line">updatedDefinitions.add(beanName);</span><br><span class="line">this.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">if (this.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(this.manualSingletonNames);</span><br><span class="line">updatedSingletons.remove(beanName);</span><br><span class="line">this.manualSingletonNames = updatedSingletons;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">//注册beanDefinition</span><br><span class="line">// Still in startup registration phase</span><br><span class="line">this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">//记录beanName</span><br><span class="line">this.beanDefinitionNames.add(beanName);</span><br><span class="line">this.manualSingletonNames.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">this.frozenBeanDefinitionNames = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (oldBeanDefinition != null || containsSingleton(beanName)) &#123;</span><br><span class="line">//重置所有beanName对应的缓存</span><br><span class="line">resetBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this.beanDefinitionMap.put(beanName, beanDefinition)</code> 这个是我们要的：将封装好的<code>BeanDefinition</code>对象与名字以键值对的形式保存到了<code>DefaultListableBeanDefinition</code>的<code>beanDefinitionMap</code>对象中。  </p><h3 id="一些类的说明"><a href="#一些类的说明" class="headerlink" title="一些类的说明"></a>一些类的说明</h3><ol><li><code>XmlBeanDefinitionReader</code>:xml配置文件读取器，已废弃</li><li><code>BeanDefinition</code>：封装了一系列信息，可以把它想象成是一个对象的各项属性获取器。</li><li><code>DefaultBeanDefinitionDocumentReader</code>：document解析器，负责一些逻辑的判断与处理</li><li><code>BeanDefinitionParserDelegate</code>:bean解析器，存放了各种标签的定义，专门用来解析spring xml配置，负责将Element对象转化为<code>BeanDefinitionHolder</code></li></ol><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2016/02/06/spring-source-load-xml/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/02/06/spring-source-load-xml/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      读取、验证并解析xml配置，封装成BeanDefinition对象
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Maven Archetype编写（二）</title>
    <link href="http://yoursite.com/2016/02/04/maven-archetype-bugfix/"/>
    <id>http://yoursite.com/2016/02/04/maven-archetype-bugfix/</id>
    <published>2016-02-04T08:32:25.000Z</published>
    <updated>2018-10-28T11:37:51.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/wengyingjian/kylin-archetype.git" target="_blank" rel="noopener">https://github.com/wengyingjian/kylin-archetype.git</a>  </p><h2 id="多模块聚合"><a href="#多模块聚合" class="headerlink" title="多模块聚合"></a>多模块聚合</h2><h3 id="聚合的优势"><a href="#聚合的优势" class="headerlink" title="聚合的优势"></a>聚合的优势</h3><p>在公司里面用到的maven项目通常都是由common、api、service三个模块聚合而成的。<br>common存放一些公用类以及接口。<br>api存放controller层往下的类。<br>service存放dao往上的类；打成jar包可作为依赖，打成war包可提供服务。  </p><p>这样不管开发还是分层都比较方便。  </p><p>所以用maven-archetype直接生成多个模块聚合的项目能够简便开发工作。    </p><h3 id="聚合Archetype的编写"><a href="#聚合Archetype的编写" class="headerlink" title="聚合Archetype的编写"></a>聚合Archetype的编写</h3><h4 id="资源存放"><a href="#资源存放" class="headerlink" title="资源存放"></a>资源存放</h4><p>所有的资源都还是存放在<code>src/main/resources/archetype-resources/</code>目录下<br>就像是这样：<br><img src="http://images2015.cnblogs.com/blog/842598/201602/842598-20160204173322804-1328226791.png" alt="">  </p><h4 id="archetype-metadata-xml"><a href="#archetype-metadata-xml" class="headerlink" title="archetype-metadata.xml"></a>archetype-metadata.xml</h4><p>原先单个模块的项目，<code>fileSet</code>等属性是放在外面的；现在多个模块的项目，只需要把原先的配置移到<code>modules</code>里面即可。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;archetype-descriptor name=&quot;$&#123;artifactId&#125;&quot;&gt;</span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module id=&quot;$&#123;rootArtifactId&#125;-api&quot; dir=&quot;__rootArtifactId__-api&quot; name=&quot;$&#123;rootArtifactId&#125;-api&quot;&gt;</span><br><span class="line">            &lt;fileSets&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; packaged=&quot;true&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; packaged=&quot;true&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/test/java&lt;/directory&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/test/resources&lt;/directory&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">            &lt;/fileSets&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;module id=&quot;$&#123;rootArtifactId&#125;-common&quot; dir=&quot;__rootArtifactId__-common&quot; name=&quot;$&#123;rootArtifactId&#125;-common&quot;&gt;</span><br><span class="line">            &lt;fileSets&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; packaged=&quot;true&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">            &lt;/fileSets&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;module id=&quot;$&#123;rootArtifactId&#125;-service&quot; dir=&quot;__rootArtifactId__-service&quot; name=&quot;$&#123;rootArtifactId&#125;-service&quot;&gt;</span><br><span class="line">            &lt;fileSets&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; packaged=&quot;true&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;*.properties&lt;/include&gt;</span><br><span class="line">                        &lt;include&gt;*.yml&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; packaged=&quot;true&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; packaged=&quot;true&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/test/java&lt;/directory&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/test/resources&lt;/directory&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">            &lt;/fileSets&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">&lt;/archetype-descriptor&gt;</span><br></pre></td></tr></table></figure><h2 id="mapper-xml文件无法找到问题"><a href="#mapper-xml文件无法找到问题" class="headerlink" title="mapper.xml文件无法找到问题"></a>mapper.xml文件无法找到问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.ibatis.binding.BindingException: Invalid bound statement (not found):</span><br></pre></td></tr></table></figure><p>问题太纠结，直接上结论：<br><img src="http://images2015.cnblogs.com/blog/842598/201602/842598-20160204173940382-2061353534.png" alt=""></p><p>不知道看出来了没有：一个是<code>resources/dao.mapper</code>一个是<code>resources/dao/mapper</code>，在idea里面的显示竟然是一样的。<br>所以<code>mapper.xml</code>无法找到的原因应该就明了了。  </p><p>不怪谁，就怪idea，就是它！定位这个问题都花了我好几天的时间，隐藏的太深的问题了。  </p><p>至于我怎么发现的，是通过target/classes下的文件发现的。<br><strong>正常能运行的：</strong><br><code>mapper.xml</code>与<code>mapper.class</code>接口类打包在同一个目录下。<br><strong>出现上述问题的：</strong><br><code>mapper.xml</code>所在的目录与<code>mapper.class</code>接口类所在的目录看上去一样（还得怪idea）。<br>但是前者是<code>classes/a.b.c.mapper.xml</code>，后者是<code>classes/a/b/c/mapper.class</code>。  </p><h2 id="mapper-xml字符替换问题"><a href="#mapper-xml字符替换问题" class="headerlink" title="mapper.xml字符替换问题"></a>mapper.xml字符替换问题</h2><p>在mybatis配置文件中，必然会用到<code>#{ }</code>这种符号，但是这个符号在被过滤的时候会被吃掉。  </p><p>解决方案：<br>maven－archetyoe用的是Velocity引擎，在下面的地址有说明：<br><a href="http://maven.apache.org/archetype/archetype-models/archetype-descriptor/archetype-descriptor.html" target="_blank" rel="noopener">http://maven.apache.org/archetype/archetype-models/archetype-descriptor/archetype-descriptor.html</a>  </p><p>所以通过查看Velocity语法即可知道如何使用里面的一些“关键字”。  </p><p>比如说要输出<code>id = #{ id }</code><br>首先在文件的开头加入以下三行：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#set( $pound = &apos;#&apos; )</span><br><span class="line">#set( $brace_b = &apos;&#123;&apos; )</span><br><span class="line">#set( $brace_e = &apos;&#125;&apos; )</span><br></pre></td></tr></table></figure><p>然后再在需要的地方添上<code>id = $pound$brace_b id $brace_e</code></p><h2 id="archetype-metadata-xml-1"><a href="#archetype-metadata-xml-1" class="headerlink" title="archetype-metadata.xml"></a>archetype-metadata.xml</h2><pre><code>&lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot;&gt;    &lt;directory&gt;src/main/resources&lt;/directory&gt;    &lt;includes&gt;        &lt;include&gt;*.properties&lt;/include&gt;        &lt;include&gt;*.yml&lt;/include&gt;    &lt;/includes&gt;&lt;/fileSet&gt;&lt;fileSet filtered=&quot;true&quot; packaged=&quot;true&quot; encoding=&quot;UTF-8&quot;&gt;    &lt;directory&gt;src/main/resources&lt;/directory&gt;    &lt;includes&gt;        &lt;include&gt;**/*.xml&lt;/include&gt;    &lt;/includes&gt;&lt;/fileSet&gt;</code></pre><p>解释：<br>filtered:对应文件中涉及到的通配符字符串是否需要由Velocity来过滤解析。<br>packaged:是否将对应的文件放置于包路径下，在例子中所有的<code>*.xml</code>文件会被放倒<code>${package}</code>路径下，原先<code>resources/dao/mapper/A.xml</code>的文件会变成<code>resources/com/a/dao/mapper/A.xml</code></p><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2016/02/04/maven-archetype-bugfix/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/02/04/maven-archetype-bugfix/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      多模块聚合、mapper.xml文件无法找到问题、mapper.xml字符串替换问题、archetype-metadata.xml更加详细的解读
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Maven Archetype编写（一）</title>
    <link href="http://yoursite.com/2016/01/31/maven-archetype-init/"/>
    <id>http://yoursite.com/2016/01/31/maven-archetype-init/</id>
    <published>2016-01-31T13:08:35.000Z</published>
    <updated>2018-10-28T11:37:51.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、链接献上"><a href="#一、链接献上" class="headerlink" title="一、链接献上"></a>一、链接献上</h2><p>参考的一个指导：<a href="http://marosmars.weebly.com/blog/maven-archetype-tutorial" target="_blank" rel="noopener">http://marosmars.weebly.com/blog/maven-archetype-tutorial</a><br>官网－关于archetype-metadata.xml 配置文件的说明：<a href="http://maven.apache.org/archetype/archetype-models/archetype-descriptor/archetype-descriptor.html" target="_blank" rel="noopener">http://maven.apache.org/archetype/archetype-models/archetype-descriptor/archetype-descriptor.html</a>  </p><p>demo项目地址：<a href="http://github.com/wengyingjian/maven-archetype-kylin" target="_blank" rel="noopener">http://github.com/wengyingjian/maven-archetype-kylin</a></p><h2 id="二、开始搞"><a href="#二、开始搞" class="headerlink" title="二、开始搞"></a>二、开始搞</h2><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h3><p>新建一个普通的maven项目（手动搞比较靠谱）<br><code>pom.xml</code>文件里面就放一些必须的配置，像我的就这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  &lt;groupId&gt;com.wengyingjian.kylin&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;kylin-archetype&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;jar&lt;/packaging&gt;</span><br></pre></td></tr></table></figure><h3 id="2-定义生成项目时的一些设置"><a href="#2-定义生成项目时的一些设置" class="headerlink" title="2.定义生成项目时的一些设置"></a>2.定义生成项目时的一些设置</h3><p>这些配置保存在<code>archetype-metadata.xml</code>文件中，位于<code>src/main/resources/META-INF/maven/</code>目录下。  </p><p>主要通过fileSet以及requiredProperty对模板文件进行一个过滤，将其中一些字符进行替换。</p><h4 id="1-fileSet"><a href="#1-fileSet" class="headerlink" title="1).fileSet"></a>1).fileSet</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--文件集定义--&gt;</span><br><span class="line">   &lt;fileSets&gt;</span><br><span class="line">       &lt;!--以&quot;__property__&quot;模式定义的变量会被对于的property值所替换--&gt;</span><br><span class="line">       &lt;!--filtered boolean  默认false,表示保持文件原样不被替换--&gt;</span><br><span class="line">       &lt;fileSet filtered=&quot;true&quot; packaged=&quot;false&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">           &lt;!--文件所在(archetype-resources目录下)同时也是生成路径--&gt;</span><br><span class="line">           &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">           &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**/*.**&lt;/include&gt;</span><br><span class="line">           &lt;/includes&gt;</span><br><span class="line">       &lt;/fileSet&gt;</span><br><span class="line">       &lt;fileSet filtered=&quot;true&quot; packaged=&quot;false&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">           &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">           &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**/*.**&lt;/include&gt;</span><br><span class="line">           &lt;/includes&gt;</span><br><span class="line">       &lt;/fileSet&gt;</span><br><span class="line">       &lt;fileSet filtered=&quot;true&quot; packaged=&quot;false&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">           &lt;directory&gt;src/test/java&lt;/directory&gt;</span><br><span class="line">           &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**/*.**&lt;/include&gt;</span><br><span class="line">           &lt;/includes&gt;</span><br><span class="line">       &lt;/fileSet&gt;</span><br><span class="line">   &lt;/fileSets&gt;</span><br></pre></td></tr></table></figure><h4 id="2-requiredProperty"><a href="#2-requiredProperty" class="headerlink" title="2).requiredProperty"></a>2).requiredProperty</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--利用此archetype生成项目必须的属性--&gt;</span><br><span class="line">    &lt;requiredProperties&gt;</span><br><span class="line">        &lt;!--由于是由Velocity引擎生成的,所以key不能带有&quot;.&quot;--&gt;</span><br><span class="line">        &lt;requiredProperty key=&quot;groupId&quot;&gt;</span><br><span class="line">            &lt;defaultValue&gt;com.wengyingjian&lt;/defaultValue&gt;</span><br><span class="line">        &lt;/requiredProperty&gt;</span><br><span class="line">    &lt;/requiredProperties&gt;</span><br></pre></td></tr></table></figure><h4 id="3-module"><a href="#3-module" class="headerlink" title="3).module"></a>3).module</h4><p>下回用到了再将</p><h3 id="3-定义模版文件"><a href="#3-定义模版文件" class="headerlink" title="3.定义模版文件"></a>3.定义模版文件</h3><p>也就是通过这个archetype，生成的项目是怎么样的。<br>这些文件位于<code>src/main/resources/archetype-resources/</code>目录下。<br>可以看到，文件的目录结构是这样的：  </p><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160131214141036-1850151919.png" alt=""></p><p>生成项目的根目录 == <code>src/main/resources/archetype-resources/</code>  </p><p>这里所有的文件，会通过<code>archetype-metadata.xml</code>的配置，进行过滤，对一些字符串进行替换。<br>所以，<code>pom.xml</code>文件的写法就是这样的：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">   &lt;groupId&gt;$&#123;groupId&#125;&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;$&#123;artifactId&#125;&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;$&#123;version&#125;&lt;/version&gt;</span><br><span class="line">   &lt;packaging&gt;jar&lt;/packaging&gt;</span><br></pre></td></tr></table></figure><h3 id="4-安装archetype"><a href="#4-安装archetype" class="headerlink" title="4.安装archetype"></a>4.安装archetype</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure><h3 id="5-使用archetype生成项目"><a href="#5-使用archetype生成项目" class="headerlink" title="5.使用archetype生成项目"></a>5.使用archetype生成项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate \</span><br><span class="line">-DarchetypeGroupId=com.wengyingjian.kylin \</span><br><span class="line">-DarchetypeArtifactId=kylin-archetype \</span><br><span class="line">-DarchetypeVersion=1.0-SNAPSHOT \</span><br><span class="line">-DgroupId=&lt;your-groupId-here&gt; \</span><br><span class="line">-DartifactId=&lt;your-artifactId-here&gt;\</span><br></pre></td></tr></table></figure><h2 id="三、一些问题"><a href="#三、一些问题" class="headerlink" title="三、一些问题"></a>三、一些问题</h2><p><strong>项目生成的时候特别的慢：</strong>   </p><p>在这个地方会卡很久：  </p><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160131215259380-40859087.png" alt=""></p><p>其实它是去到中央仓库找catalog去了，那边的速度慢的，有些时候真的想哭，而且这个文件也蛮大，所以要点时间。<br>比较好的解决方法就是我们把这个catalog下载下来，然后指定使用本地的这个，就像这样： </p><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160131215520989-581317849.png" alt=""></p><p>没错，下载了4分钟，如果不放到本地，每次新建项目需要等待这么久。  </p><p>顺便贴下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://repo1.maven.org/maven2/archetype-catalog.xml</span><br></pre></td></tr></table></figure><p>将自己的archetype加入到此catalog中：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;archetype&gt;</span><br><span class="line">     &lt;groupId&gt;com.wengyingjian.kylin&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;kylin-archetype&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">     &lt;description&gt;Blank Project for kylin&lt;/description&gt;</span><br><span class="line">   &lt;/archetype&gt;</span><br></pre></td></tr></table></figure><p>将该文件移动到<code>~/.m2/</code>路径下，然后再执行命令的时候指定<code>-DarchetypeCatalog=local</code>即可。  </p><p>对于IDEA编译器，只需要在maven命令中添加一个参数即可，就像这样：  </p><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160131220246974-1694776895.png" alt=""></p><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2016/01/31/maven-archetype-init/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/01/31/maven-archetype-init/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      介绍maven archetype的配置，编写demo，并解决期间遇到的项目生成过慢问题。
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Maven Archetype编写（一）</title>
    <link href="http://yoursite.com/2016/01/31/maven-archetype-init.md/"/>
    <id>http://yoursite.com/2016/01/31/maven-archetype-init.md/</id>
    <published>2016-01-31T13:08:35.000Z</published>
    <updated>2018-10-28T11:36:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、链接献上"><a href="#一、链接献上" class="headerlink" title="一、链接献上"></a>一、链接献上</h2><p>参考的一个指导：<a href="http://marosmars.weebly.com/blog/maven-archetype-tutorial" target="_blank" rel="noopener">http://marosmars.weebly.com/blog/maven-archetype-tutorial</a><br>官网－关于archetype-metadata.xml 配置文件的说明：<a href="http://maven.apache.org/archetype/archetype-models/archetype-descriptor/archetype-descriptor.html" target="_blank" rel="noopener">http://maven.apache.org/archetype/archetype-models/archetype-descriptor/archetype-descriptor.html</a>  </p><p>demo项目地址：<a href="http://github.com/wengyingjian/maven-archetype-kylin" target="_blank" rel="noopener">http://github.com/wengyingjian/maven-archetype-kylin</a></p><h2 id="二、开始搞"><a href="#二、开始搞" class="headerlink" title="二、开始搞"></a>二、开始搞</h2><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h3><p>新建一个普通的maven项目（手动搞比较靠谱）<br><code>pom.xml</code>文件里面就放一些必须的配置，像我的就这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  &lt;groupId&gt;com.wengyingjian.kylin&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;kylin-archetype&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;jar&lt;/packaging&gt;</span><br></pre></td></tr></table></figure><h3 id="2-定义生成项目时的一些设置"><a href="#2-定义生成项目时的一些设置" class="headerlink" title="2.定义生成项目时的一些设置"></a>2.定义生成项目时的一些设置</h3><p>这些配置保存在<code>archetype-metadata.xml</code>文件中，位于<code>src/main/resources/META-INF/maven/</code>目录下。  </p><p>主要通过fileSet以及requiredProperty对模板文件进行一个过滤，将其中一些字符进行替换。</p><h4 id="1-fileSet"><a href="#1-fileSet" class="headerlink" title="1).fileSet"></a>1).fileSet</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--文件集定义--&gt;</span><br><span class="line">   &lt;fileSets&gt;</span><br><span class="line">       &lt;!--以&quot;__property__&quot;模式定义的变量会被对于的property值所替换--&gt;</span><br><span class="line">       &lt;!--filtered boolean  默认false,表示保持文件原样不被替换--&gt;</span><br><span class="line">       &lt;fileSet filtered=&quot;true&quot; packaged=&quot;false&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">           &lt;!--文件所在(archetype-resources目录下)同时也是生成路径--&gt;</span><br><span class="line">           &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">           &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**/*.**&lt;/include&gt;</span><br><span class="line">           &lt;/includes&gt;</span><br><span class="line">       &lt;/fileSet&gt;</span><br><span class="line">       &lt;fileSet filtered=&quot;true&quot; packaged=&quot;false&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">           &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">           &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**/*.**&lt;/include&gt;</span><br><span class="line">           &lt;/includes&gt;</span><br><span class="line">       &lt;/fileSet&gt;</span><br><span class="line">       &lt;fileSet filtered=&quot;true&quot; packaged=&quot;false&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">           &lt;directory&gt;src/test/java&lt;/directory&gt;</span><br><span class="line">           &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**/*.**&lt;/include&gt;</span><br><span class="line">           &lt;/includes&gt;</span><br><span class="line">       &lt;/fileSet&gt;</span><br><span class="line">   &lt;/fileSets&gt;</span><br></pre></td></tr></table></figure><h4 id="2-requiredProperty"><a href="#2-requiredProperty" class="headerlink" title="2).requiredProperty"></a>2).requiredProperty</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--利用此archetype生成项目必须的属性--&gt;</span><br><span class="line">    &lt;requiredProperties&gt;</span><br><span class="line">        &lt;!--由于是由Velocity引擎生成的,所以key不能带有&quot;.&quot;--&gt;</span><br><span class="line">        &lt;requiredProperty key=&quot;groupId&quot;&gt;</span><br><span class="line">            &lt;defaultValue&gt;com.wengyingjian&lt;/defaultValue&gt;</span><br><span class="line">        &lt;/requiredProperty&gt;</span><br><span class="line">    &lt;/requiredProperties&gt;</span><br></pre></td></tr></table></figure><h4 id="3-module"><a href="#3-module" class="headerlink" title="3).module"></a>3).module</h4><p>下回用到了再将</p><h3 id="3-定义模版文件"><a href="#3-定义模版文件" class="headerlink" title="3.定义模版文件"></a>3.定义模版文件</h3><p>也就是通过这个archetype，生成的项目是怎么样的。<br>这些文件位于<code>src/main/resources/archetype-resources/</code>目录下。<br>可以看到，文件的目录结构是这样的：  </p><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160131214141036-1850151919.png" alt=""></p><p>生成项目的根目录 == <code>src/main/resources/archetype-resources/</code>  </p><p>这里所有的文件，会通过<code>archetype-metadata.xml</code>的配置，进行过滤，对一些字符串进行替换。<br>所以，<code>pom.xml</code>文件的写法就是这样的：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">   &lt;groupId&gt;$&#123;groupId&#125;&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;$&#123;artifactId&#125;&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;$&#123;version&#125;&lt;/version&gt;</span><br><span class="line">   &lt;packaging&gt;jar&lt;/packaging&gt;</span><br></pre></td></tr></table></figure><h3 id="4-安装archetype"><a href="#4-安装archetype" class="headerlink" title="4.安装archetype"></a>4.安装archetype</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure><h3 id="5-使用archetype生成项目"><a href="#5-使用archetype生成项目" class="headerlink" title="5.使用archetype生成项目"></a>5.使用archetype生成项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate \</span><br><span class="line">-DarchetypeGroupId=com.wengyingjian.kylin \</span><br><span class="line">-DarchetypeArtifactId=kylin-archetype \</span><br><span class="line">-DarchetypeVersion=1.0-SNAPSHOT \</span><br><span class="line">-DgroupId=&lt;your-groupId-here&gt; \</span><br><span class="line">-DartifactId=&lt;your-artifactId-here&gt;\</span><br></pre></td></tr></table></figure><h2 id="三、一些问题"><a href="#三、一些问题" class="headerlink" title="三、一些问题"></a>三、一些问题</h2><p><strong>项目生成的时候特别的慢：</strong>   </p><p>在这个地方会卡很久：  </p><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160131215259380-40859087.png" alt=""></p><p>其实它是去到中央仓库找catalog去了，那边的速度慢的，有些时候真的想哭，而且这个文件也蛮大，所以要点时间。<br>比较好的解决方法就是我们把这个catalog下载下来，然后指定使用本地的这个，就像这样： </p><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160131215520989-581317849.png" alt=""></p><p>没错，下载了4分钟，如果不放到本地，每次新建项目需要等待这么久。  </p><p>顺便贴下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://repo1.maven.org/maven2/archetype-catalog.xml</span><br></pre></td></tr></table></figure><p>将自己的archetype加入到此catalog中：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;archetype&gt;</span><br><span class="line">     &lt;groupId&gt;com.wengyingjian.kylin&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;kylin-archetype&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">     &lt;description&gt;Blank Project for kylin&lt;/description&gt;</span><br><span class="line">   &lt;/archetype&gt;</span><br></pre></td></tr></table></figure><p>将该文件移动到<code>~/.m2/</code>路径下，然后再执行命令的时候指定<code>-DarchetypeCatalog=local</code>即可。  </p><p>对于IDEA编译器，只需要在maven命令中添加一个参数即可，就像这样：  </p><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160131220246974-1694776895.png" alt=""></p><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2016/01/31/maven-archetype-init/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/01/31/maven-archetype-init/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      介绍maven archetype的配置，编写demo，并解决期间遇到的项目生成过慢问题。
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Maven Autoconf打包问题</title>
    <link href="http://yoursite.com/2016/01/23/maven-autoconf-fix/"/>
    <id>http://yoursite.com/2016/01/23/maven-autoconf-fix/</id>
    <published>2016-01-23T13:13:55.000Z</published>
    <updated>2018-10-28T11:37:51.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近又把毕业设计的项目拿出来，重新做。  </p><p>一来为了好对之前的项目“重构”，毕竟之前写的零零散散太乱了；二来也熟悉熟悉IDEA开发环境。  </p><p>从Eclipse转向IDEA，maven项目可以一个里面套多个了，所以现在将毕业设计所需要的一些模块都放到了一起，就像是这样：    </p><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160123212535718-1498842077.png" alt="">  </p><p>这里就需要自己新建项目。<br>之前在公司写的项目大多是已经搭建好了的，难得有个从0到1的项目记得还是找的一个模板改改用的。  </p><p>所以这次在<code>autoconfig</code>的时候就遇到了问题，而且搞了好几个小时才找到问题所在。  </p><h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><code>log4j2</code>:<a href="https://github.com/wengyingjian/kylin/tree/1c649e2391ff02d31e9a531c285849f719e488ae" target="_blank" rel="noopener">https://github.com/wengyingjian/kylin/tree/1c649e2391ff02d31e9a531c285849f719e488ae</a>  </p><p><code>demo-kyliy</code>:<a href="https://github.com/wengyingjian/demo-kylin/tree/66000f28327acc259ed4ad20e8bcffc182a23563" target="_blank" rel="noopener">https://github.com/wengyingjian/demo-kylin/tree/66000f28327acc259ed4ad20e8bcffc182a23563</a></p><h1 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h1><h2 id="再补充下背景"><a href="#再补充下背景" class="headerlink" title="再补充下背景"></a>再补充下背景</h2><p>项目要边写边测试，先来的是最简单的  </p><p><code>log4j2</code>模块：只负责打印，收集日志。对应的也只需要配置文件，而无任何的java代码。  </p><p>既然要配置文件，这里就要用到<code>autoconf</code>。</p><h2 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h2><p>将<code>log4j2</code>模块打包以后，用另外一个项目<code>demo-kylin</code>来使用。  </p><p>在打包<code>demo-kylin</code>项目的时候直接跳过了自动配置，就像是这样： </p><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160123214053593-2060259371.png" alt="">  </p><p>都已经去找了配置文件，结果配置文件没找到，再一看，竟然没有东西需要配置。<br>说明<code>autoconf</code>这个插件没有找到让它来自动配置的相关文件。  </p><h1 id="查找问题"><a href="#查找问题" class="headerlink" title="查找问题"></a>查找问题</h1><h2 id="测试项目方面查找"><a href="#测试项目方面查找" class="headerlink" title="测试项目方面查找"></a>测试项目方面查找</h2><p>从测试项目<code>demo-kylin</code>方面来看。<br>就是点开<code>External Libraries</code>这个依赖看看<code>log4j2</code>到底长成啥样了。<br>一看吓一跳：<br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160123214610656-630660547.png" alt="">  </p><p>整个展开以后未看到<code>autoconf</code>相关的文件，如<code>auto-conf.xml</code>、<code>*.vm</code>。  </p><p>那看来在<code>log4j2</code>这边就已经出了问题。  </p><h2 id="被依赖项目方面查找"><a href="#被依赖项目方面查找" class="headerlink" title="被依赖项目方面查找"></a>被依赖项目方面查找</h2><p>首先，展开<code>log4j2</code>项目来看，它也表示很“无辜”：该有的文件基本都有了啊：<br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160123214940437-1712705848.png" alt="">  </p><p>然后再打包一次看看，日志的显示如下：<br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160123215315656-1031201373.png" alt="">  </p><p>总之就是在表示它们都没看到<code>*.xml</code>、<code>*.vm</code>这2个文件。 </p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>那肯定是<code>autoconf</code>相关的文件放错位置了，导致程序找不到。<br>想想也是没有找到问题所在。  </p><ul><li>特意去看了之前的开发环境：的确是放在<code>src/main/webapp/META-INF/autoconf</code>目录下的，也都可行。  </li><li><p>也瞄了一眼<a href="http://openwebx.org/docs/autoconfig.html#d0e17306" target="_blank" rel="noopener">http://openwebx.org/docs/autoconfig.html#d0e17306</a>看似比较权威的说明，好像也没问题。<br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160123220103406-1277988398.png" alt=""></p></li><li><p>再看看网上的一些博客，都是说放到<code>META-INF/autoconf</code>目录下的。  </p></li></ul><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>google没有找到问题所在，只好回到baidu。<br>没想到baidu更穷，提供的全是一些博客，甚至点去内容都是一样的。  </p><p>看来还是老问题啊：犯了比较傻的错误，以致都没什么人犯过，所以网上都搜不到。  </p><p>所以决定沉下气来再仔细看看那篇看似比较权威的文档：<a href="http://openwebx.org/docs/autoconfig.html#d0e17306" target="_blank" rel="noopener">http://openwebx.org/docs/autoconfig.html#d0e17306</a>  </p><h2 id="找到问题"><a href="#找到问题" class="headerlink" title="找到问题"></a>找到问题</h2><p>在上面那张图下面，就是这个：  </p><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160123220540797-445536755.png" alt="">  </p><p>恍然大悟，我的这个是<code>jar</code>包啊，哪来的webapp！<br>之前项目是<code>war</code>项目，所以它们能够运行！  </p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>给文件搬家即可  </p><p><code>log4j2</code>项目上看：  </p><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160123220733765-1539785262.png" alt="">  </p><p>从依赖上看：  </p><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160123220903422-624602064.png" alt=""></p><p>最后，在<code>demo-kylin</code>项目打包的时候，跳出如下提示：  </p><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160123221059937-2135631978.png" alt=""></p><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2016/01/23/maven-autoconf-fix/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/01/23/maven-autoconf-fix/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      需要autocofig的项目被其他项目引用，打包的时候自动配置无法启用问题
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Docker是什么</title>
    <link href="http://yoursite.com/2016/01/19/docker-what-is/"/>
    <id>http://yoursite.com/2016/01/19/docker-what-is/</id>
    <published>2016-01-19T00:15:13.000Z</published>
    <updated>2018-10-28T11:37:51.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker？"><a href="#Docker？" class="headerlink" title="Docker？"></a>Docker？</h1><p>之前有听说过docker这个东西，印象比较深的一次就是在耗子的微博里面看到其对docker有非常高的评价。从此便觉得docker是个牛逼的东西。 </p><p>但是这牛逼的东西到底是用来干啥的呢？由于docker的出场方式通常是”docker容器“，所以我知道它是一个容器。而且docker出现的地方都会配个图，就是那种几个长方体叠在一起的图，看到它就会让我想到网络模型、android架构等一系列的、牛逼的图。  </p><p>所以在我的印象中，docker应该是一个非常底层而又深奥的容器，跟”Tomcat容器“应该是没法比的。  </p><p>docker很厉害的样子，但是跟我又有什么关系呢，在我目前所接触的Java领域甚至还没听说过这个东西－－等我哪天厉害了我可以再考虑考虑回来研究研究docker。。  </p><hr><p>最近公司里面用到了spring-cloud，里面又出现了“docker”这个词，所以，至少我应该知道docker是干啥的吧！  </p><h1 id="那么，docker是什么"><a href="#那么，docker是什么" class="headerlink" title="那么，docker是什么"></a>那么，docker是什么</h1><p>借用官方的说明：  </p><blockquote><p>Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。 </p></blockquote><p>然而对于我来说，看了等于没看。虽然等我学完了docker可能会觉得这讲的很有道理，但是很遗憾，现在功力不足。  </p><p>所以现在最好的办法就是：动手试试</p><h1 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>ubuntu：</p><pre><code>sudo apt-get updatesudo apt-get install -y docker.iosudo ln -sf /usr/bin/docker.io /usr/local/bin/dockersudo sed -i &apos;$acomplete -F _docker docker&apos; /etc/bash_completion.d/docker.io</code></pre><p>此时docker已安装完成，可以通过<code>docker --version</code>查看。 </p><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160119085502953-1744327311.png" alt="">  </p><h2 id="获取镜像？"><a href="#获取镜像？" class="headerlink" title="获取镜像？"></a>获取镜像？</h2><p>第一次看到这个条目的时候，我就懵了，这里的“获取镜像”又是啥！  </p><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>乖乖的按步骤来看看：  </p><p>从Docker Hub仓库下载一个Ubuntu12.04操作系统的镜像。</p><pre><code>sudo docker pull ubuntu:12.04</code></pre><p>执行完该条命令以后只需等待镜像下载完毕即可。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>该命令实际上相当于 <code>$ sudo docker pull registry.hub.docker.com/ubuntu:12.04</code>命令，即从注册服务器 <code>registry.hub.docker.com</code>中的 ubuntu 仓库来下载标记为 12.04 的镜像。  </p><p>这个命令也类似于Git操作：从仓库里面<code>pull</code>出我要的东西来。  </p><h3 id="获取完了就能用？"><a href="#获取完了就能用？" class="headerlink" title="获取完了就能用？"></a>获取完了就能用？</h3><pre><code>sudo docker run -t -i ubuntu:12.04 /bin/bash</code></pre><p>执行完以上命令后进入到一个新的终端－－就是docker之中。  </p><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160119090513609-217285656.png" alt=""></p><p><strong>原来docker就是一个虚拟机啊！</strong></p><h1 id="一些操作"><a href="#一些操作" class="headerlink" title="一些操作"></a>一些操作</h1><h2 id="查看已有的镜像"><a href="#查看已有的镜像" class="headerlink" title="查看已有的镜像"></a>查看已有的镜像</h2><pre><code>sudo docker images</code></pre><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160119090821187-218889474.png" alt=""><br>说明在<code>ubuntu</code>仓库有一个标签为<code>12.04</code>、ID为<code>bad926a6fb50</code>、五个星期前创建的、大小为<code>137M</code>的一个镜像。  </p><h2 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h2><h3 id="启动一个docker容器"><a href="#启动一个docker容器" class="headerlink" title="启动一个docker容器"></a>启动一个docker容器</h3><h4 id="解释一下之前的命令"><a href="#解释一下之前的命令" class="headerlink" title="解释一下之前的命令"></a>解释一下之前的命令</h4><pre><code>sudo docker run -t -i ubuntu:12.04 /bin/bash</code></pre><p>开启一个新的容器，其镜像位于<code>ubuntu</code>仓库，标签号为<code>12.04</code>。如果未指定<code>12.04</code>，则默认为<code>latest</code>。  </p><p>开启容器后启动一个 bash 终端，允许用户进行交互。  </p><p>其中，<code>-t</code>选项让Docker分配一个伪终端<code>（pseudo-tty）</code>并绑定到容器的标准输入上， <code>-i</code>则让容器的标准输入保持打开。  </p><h4 id="后台启动容器"><a href="#后台启动容器" class="headerlink" title="后台启动容器"></a>后台启动容器</h4><pre><code>sudo docker -idt ubuntu:12.04</code></pre><p>多了一个<code>-d</code>（Daemonized)选项，说明后台启动。  </p><h3 id="查看docker运行中的容器"><a href="#查看docker运行中的容器" class="headerlink" title="查看docker运行中的容器"></a>查看docker运行中的容器</h3><pre><code>sudo docker ps </code></pre><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160119091138297-1310341337.png" alt="">  </p><p>说明一个有ID为<code>add4bd1abadf</code>的容器：开启并启动于一个小时前，它的名字为<code>berserk_mestorf</code>。  </p><h3 id="查看所有的docker容器"><a href="#查看所有的docker容器" class="headerlink" title="查看所有的docker容器"></a>查看所有的docker容器</h3><pre><code>sudo docker ps -a</code></pre><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160119091441218-431169080.png" alt=""></p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><pre><code>sudo docker attach container_id/names</code></pre><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160119092830562-1127269048.png" alt="">  </p><p>中间好像阻塞了，不过可以看到，最后的实例由<code>iZ2855ufp2yZ</code>变成了<code>add4bd1abadf</code>，说明进入docker容器成功了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>谈谈目前的理解  </p><h2 id="docker是什么"><a href="#docker是什么" class="headerlink" title="docker是什么"></a>docker是什么</h2><p>docker容器，这个容器原来就是虚拟机，而且这个虚拟机非常的轻量－－通过<code>ps</code>命令可以看到它只启动了一些我们用到的进程。</p><h2 id="docker有什么用"><a href="#docker有什么用" class="headerlink" title="docker有什么用"></a>docker有什么用</h2><p>虚拟机又有什么用</p><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2016/01/19/docker-what-is/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/01/19/docker-what-is/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      一个docker的helloWorld，用于了解docker究竟是什么
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Nginx学习笔记（三）－Nginx作为反向代理</title>
    <link href="http://yoursite.com/2016/01/10/nginx-note-reverse-proxy/"/>
    <id>http://yoursite.com/2016/01/10/nginx-note-reverse-proxy/</id>
    <published>2016-01-10T07:44:51.000Z</published>
    <updated>2018-10-28T11:37:51.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反向代理简介"><a href="#反向代理简介" class="headerlink" title="反向代理简介"></a>反向代理简介</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Nginx能够作为一个反向代理来终结来自客户端的请求，并且向上游服务器打开一个新的请求。在这个处理的过程中，为了更好地响应客户端请求，该请求可以根据它的URI、客户端参数或者一些其他的逻辑进行拆分。通过代理服务器，请求的原始URL中的任何部分能够以这种方式进行转换。  </p><p>代理到上有服务器的配置中，最重要的是<strong>proxy_pass</strong>指令。该指令有一个参数，URL请求将会被转换，带有URI部分的<code>proxy_pass</code>指令将会使用该URI替代<code>request_uri</code>部分。</p><h3 id="url转换"><a href="#url转换" class="headerlink" title="url转换"></a>url转换</h3><p>下面的例子中的<code>/proxy_pass</code>，在请求传递到上游服务器时将会被替代为<code></code></p><pre><code>location /proxy_pass {        proxy_pass http://121.42.32.99:8080/nginxserver/proxy_pass/request_from;}</code></pre><h4 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h4><ol><li>开启一个客户端，修改<code>$NGINX_HOME/conf/nginx.conf</code>文件：在<code>server</code>域中加入以上的<code>location</code>代码块。  </li><li>重新加载nginx配置文件，使用<code>nginx -s reload</code>命令。</li><li>访问<a href="">http://host:80/proxy_pass</a>。</li><li>理论上讲，此时应该访问到的应该是<a href="">http://121.42.32.99:8080/nginxserver/proxy_pass/request_from</a> 的内容。所以我们需要写一个<a href="https://github.com/wengyingjian/nginx-server-console.git" target="_blank" rel="noopener">java服务端</a>，用来监测客户端的访问。由于测试时候部署频繁，所以安利一下本人的全家桶系列之<a href="http://wengyingjian.com/2015/12/18/java-deploy2/" target="_blank" rel="noopener">自动化部署工具</a>。</li></ol><h4 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h4><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160111150730007-33598305.png" alt="">  </p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>其中，服务端java代码如下：  </p><pre><code>@RestController@RequestMapping(&quot;proxy_pass&quot;)public class ProxyPassController {    @RequestMapping(&quot;test_proxy_pass&quot;)    public Object proxyPass() {        return &quot;proxy pass success&quot;;    }    @RequestMapping(&quot;request_from&quot;)    public Object requestFrom(HttpServletRequest request) {        return String.format(&quot;%s\n%s\n%s&quot;, request.getRequestURI(), request.getRemoteAddr(), request.getRemoteHost());    }}</code></pre><p>说明两件事情：  </p><ol><li>请求被代理了，转发到了目标的地址。</li><li>请求被终结了，java代码处获得的uri为nginx服务器的地址。  </li></ol><h3 id="url转换特殊情况"><a href="#url转换特殊情况" class="headerlink" title="url转换特殊情况"></a>url转换特殊情况</h3><h4 id="location处定义了正则表达式"><a href="#location处定义了正则表达式" class="headerlink" title="location处定义了正则表达式"></a>location处定义了正则表达式</h4><p>以下的配置中，真正转发到的地址是<a href="">http://121.42.32.99:8080/nginxserver/proxy_pass/test_proxy_pass</a>，而非<a href="http://121.42.32.99:8080/proxy" target="_blank" rel="noopener">http://121.42.32.99:8080/proxy</a>：  </p><pre><code>location ~ ^/nginxserver/proxy_pass/test_proxy_pass {        proxy_pass http://121.42.32.99:8080/proxy;                }</code></pre><hr><p>事实上，现在的nginx版本如果还这样配置的话是会报错的：如果<code>location</code>处设置了正则表达式，不允许<code>proxy_pass</code>处指定路径。<br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160111151922132-1700136543.png" alt=""></p><h4 id="location内有rewrite改变了uri"><a href="#location内有rewrite改变了uri" class="headerlink" title="location内有rewrite改变了uri"></a>location内有rewrite改变了uri</h4><p>如果在<code>location</code>内有<code>rewrite</code>改变了URI，那么Nginx使用这个URI处理这个请求，不再发生转换。  </p><p>在下面的例子中，URI传递到上游服务器的将会是<code>/index.php?page=&lt;match&gt;</code>，这个<code>&lt;match&gt;</code>会是来自括号内捕获的参数，而不是预期的<code>/index</code>(<code>proxy_pass</code>指令指示的部分)。</p><pre><code>location / {    rewrite /(.*)$/index.php?page=$1 break;    proxy_pass http://localhost:8080/index;}</code></pre><p><strong>注意：</strong><br>在<code>rewrite</code>指令中，<code>break</code>标记用于立即停止<code>rewrite</code>模块的所有指令。</p><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2016/01/10/nginx-note-reverse-proxy/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/01/10/nginx-note-reverse-proxy/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      反向代理介绍、上游服务器类型、转换“if”配置为更现代的处理、使用错误文档处理上游问题、确定客户端真实的IP地址
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx学习笔记（二）－配置指南</title>
    <link href="http://yoursite.com/2016/01/10/nginx-note-config/"/>
    <id>http://yoursite.com/2016/01/10/nginx-note-config/</id>
    <published>2016-01-10T04:42:12.000Z</published>
    <updated>2018-10-28T11:37:51.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本配置格式"><a href="#基本配置格式" class="headerlink" title="基本配置格式"></a>基本配置格式</h1><p>基本的Nginx配置文件由若干部分组成。每一个部分都是通过下列方法定义的。  </p><pre><code>&lt;section&gt; {    &lt;directive&gt; &lt;parameters&gt;;}</code></pre><p><strong>说明：</strong>  </p><p>每一个指令行都由分号<code>;</code>结束，这标记着一行的结束。<br>大括号<code>{}</code>实际上表示一个新上下文（context），但是大多数情况下我们将他们作为“节、部分（section）”来读。  </p><h1 id="Nginx全局配置参数"><a href="#Nginx全局配置参数" class="headerlink" title="Nginx全局配置参数"></a>Nginx全局配置参数</h1><p>全局配置部分被用于配置对整个server都有效的参数和前一个章节中的例外格式。全局部分可能包含配置指令，例如<code>user</code>和<code>worker_processes</code>，这里没有大括号<code>{}</code>包围全局部分。  </p><p>全局配置指令：<br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160110125603450-1195119789.png" alt="">  </p><p>简短的例子(<code>nginx.conf</code>)：  </p><pre><code>#使用用户www来运行user www;#1个工作线程worker_processes  1;#显式指定error log日志存放路径#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#显式指定pid文件存放路径#pid        logs/nginx.pid;#为events模块配置一个新的上下文events {#最大连接数    worker_connections  1024;}</code></pre><h1 id="使用include文件"><a href="#使用include文件" class="headerlink" title="使用include文件"></a>使用include文件</h1><p>在Nginx配置文件中，include文件可以在任何地方。<br>只要保证被include的文件符合正确的Nginx语法（即配置指令和块），然后指定这些文件的路径即可。  </p><p>demo(<code>nginx.conf</code>)：  </p><pre><code>include mine.types;</code></pre><p>以上的<code>mine.types</code>是相对路径的表示方法，则依据主配置文件<code>nginx.conf</code>路径进行搜索。  </p><p><code>nginx.conf</code>文件的绝对路径为<code>/opt/nginx/conf/nginx.conf</code>，则以上配置等价于：</p><pre><code>include /opt/nginx/conf/mine.types;</code></pre><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>在路径中出现通配符可以表示多个配置文件。  </p><p>demo:  </p><pre><code>include /opt/nginx/conf/*.types; </code></pre><h2 id="测试配置文件"><a href="#测试配置文件" class="headerlink" title="测试配置文件"></a>测试配置文件</h2><p>要想测试配置文件（包括include内容）语法是否正确，可用以下命令进行测试：  </p><pre><code>nginx -t -c &lt;path-to-nginx.conf&gt;    </code></pre><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160110131332231-851007967.png" alt=""></p><h1 id="Http的server部分"><a href="#Http的server部分" class="headerlink" title="Http的server部分"></a>Http的server部分</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Http中，server部分或者是Http配置context都是可用的，除非在编译安装Nginx时没有包含Http模块（<code>--without-http</code>）。<br>这部分控制了Http模块的方方面面，是使用最多的一个部分。  </p><p>本部分的指令用于处理Http连接，因此该模块提供了相当数量的指令。为了更容易理解这些指令，我们将它们划分为不同的类型来讲述。  </p><h2 id="客户端指令"><a href="#客户端指令" class="headerlink" title="客户端指令"></a>客户端指令</h2><p>这一组指令用于处理客户端连接本身的各个方面，以及不同类型的客户端。<br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160110131901403-1506126564.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160110131910481-511195115.png" alt=""></p><h2 id="文件I-O指令"><a href="#文件I-O指令" class="headerlink" title="文件I/O指令"></a>文件I/O指令</h2><p>这些指令用于控制Nginx如何投递静态文件，以及如何管理文件描述符。<br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160110132002746-279439449.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160110132008903-305532260.png" alt=""></p><h2 id="Hash指令"><a href="#Hash指令" class="headerlink" title="Hash指令"></a>Hash指令</h2><p>这组hash指令控制Nginx分配给某些变量多大的静态内存。</p><p>在启动和重新配置时，Nginx会计算需要的最小值。在Nginx发出警告时，你几乎只需要调整一个<code>*_hash_max_size</code> 指令的参数就可以达到效果。<code>*_hash_bucket_size</code>变量被设置了默认值，以便满足多处理器缓存行降低检索需要的检索查找，因此基本不需要改变，格外更详细的内容参考<a href="http://nginx.org/en/docs/hash.html" target="_blank" rel="noopener">http://nginx.org/en/docs/hash.html</a><br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160110132055996-1808019028.png" alt=""></p><h2 id="Socket指令"><a href="#Socket指令" class="headerlink" title="Socket指令"></a>Socket指令</h2><p>这些指令描述了Nginx如何设置创建TCP套接字的变量选项。<br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160110132109840-674711776.png" alt=""></p><h2 id="示例配置文件"><a href="#示例配置文件" class="headerlink" title="示例配置文件"></a>示例配置文件</h2><p>demo：  </p><pre><code>http {    include mime.types;    default_type application/octet-stream;    sendfile on;    tcp_nopush on;    tcp_nodelay on;    keepalive_timeout 65;    server_names_hash_max_size 1024;}  </code></pre><p>在<code>nginx.conf</code>文件中上面的这部分内容跟随在全局配置指令之后。  </p><h1 id="虚拟服务器部分"><a href="#虚拟服务器部分" class="headerlink" title="虚拟服务器部分"></a>虚拟服务器部分</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>任何由关键字<code>server</code>开始的部分都被称作“虚拟服务器”部分。<br>它描述的是一组根据<code>server_name</code>指令逻辑分割的资源，这些虚拟服务器响应Http请求，因此它们都包含在http部分中。  </p><p>一个虚拟服务器由<code>listen</code>和<code>server_name</code>指令组合定义。</p><h2 id="listen指令"><a href="#listen指令" class="headerlink" title="listen指令"></a>listen指令</h2><p><code>listen</code>指令定义了一个IP地址/端口组合或者是UNIX域套接字路径。  </p><pre><code>listen address[:port];listen port;listen unix:path;</code></pre><p><code>listen</code>指令还有一些其他的可选参数</p><h3 id="listen指令的参数"><a href="#listen指令的参数" class="headerlink" title="listen指令的参数"></a>listen指令的参数</h3><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160110134452950-383880445.png" alt=""></p><h2 id="server-name指令"><a href="#server-name指令" class="headerlink" title="server_name指令"></a>server_name指令</h2><p><code>server_name</code>指令可以用来解决一些配置问题。 </p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>它的默认值为<code>&quot;&quot;</code>，这意味着server部分没有<code>server_name</code>指令，对于没有设置Host头字段的请求将会匹配该server处理。我们就可以设置这个server来丢弃这种缺乏Host头的请求：  </p><pre><code>server {    listen 80;    return 444;}</code></pre><p>这里是用Http非标准代码<code>444</code>使得Nginx立即关闭一个连接。  </p><h3 id="通配符-1"><a href="#通配符-1" class="headerlink" title="通配符"></a>通配符</h3><ol><li>通配符可以替代部分子域名：<code>*.example.com</code>。</li><li>通配符可以替代顶级域部分：<code>www.example.*</code>。</li><li>一种特殊形式将匹配子域或域本身。</li></ol><p><code>.example.com</code>匹配<code>*.example.com</code>也包括<code>example.com</code></p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>通过在域名前面加上波浪号（<code>~</code>），正则表达式可以被作为参数应用于<code>server_name</code>：  </p><pre><code>server_name~^www\.example\.com$;server_name~^www(\d+).example\.(com)$;</code></pre><p>后一种形式是利用捕获，可以在以后引用中进一步设置（用<code>$1</code>,<code>$2</code>等）指令中使用。  </p><h2 id="服务器绑定遵循逻辑"><a href="#服务器绑定遵循逻辑" class="headerlink" title="服务器绑定遵循逻辑"></a>服务器绑定遵循逻辑</h2><p>对于一个特定的请求，确定哪些虚拟服务器提供该请求的服务时，应该遵循以下的逻辑：  </p><ol><li>匹配IP地址和<code>listen</code>指令指定的端口。</li><li>将Host头字段作为一个字符串匹配<code>server_name</code>指令。</li><li>将Host头字段与<code>server_name</code>指令值字符串的开始部分做匹配。</li><li>将Host头字段与<code>server_name</code>指令值字符串的尾部分做匹配。</li><li>将Host头字段与<code>server_name</code>指令值进行正则表达式匹配。</li><li>如果所有Host头匹配失败，那么将会转向<code>listen</code>指令标记的<code>default_server</code>。</li><li>如果所有的Host头匹配失败，并且没有<code>default_server</code>，那么将会转向第一个server的<code>listen</code>指令，以满足第一步。  </li></ol><p>逻辑图：<br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160110141351590-484523422.png" alt=""></p><h2 id="default-server"><a href="#default-server" class="headerlink" title="default_server"></a>default_server</h2><p><code>default_server</code>被用于处理其他方式没有处理的请求。因此推荐总是明确地设置<code>default_server</code>，以便这些没有被处理的请求通过这种定义的方式处理。  </p><p>出了这个用法以外，<code>default_server</code>也可以使用同样的<code>listen</code>指令配置若干个虚拟服务器。这里设置的任何指令都将会在匹配的server区段有效。  </p><h1 id="Locations-where-when-how"><a href="#Locations-where-when-how" class="headerlink" title="Locations-where,when,how"></a>Locations-where,when,how</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>location指令可以用在虚拟服务器server部分，并且意味着提供来自客户端的URI或者内部重定向访问。除少数情况外，location也可以被嵌套使用，它们被称作为特定的配置尽可能地处理请求。  </p><h2 id="location定义"><a href="#location定义" class="headerlink" title="location定义"></a>location定义</h2><pre><code>location [modifier] uri {    ...}</code></pre><p>或者是命名location:</p><pre><code>location @name {    ...}</code></pre><p>命令location仅对内部访问重定向，在进入一个location之前它会保留被请求的URI部分。命名location只能够在server级别定义。  </p><h2 id="修饰符-modifier"><a href="#修饰符-modifier" class="headerlink" title="修饰符(modifier)"></a>修饰符(modifier)</h2><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160110143757965-228135102.png" alt=""></p><h2 id="location匹配"><a href="#location匹配" class="headerlink" title="location匹配"></a>location匹配</h2><p>当一个请求进入时，URI将会被检测匹配一个最佳的location。</p><ul><li>没有正则表达式的location被作为最佳的匹配，独立于含有正则表达式的location顺序。</li><li>在配置文件中按照查找顺序进行正则表达式匹配，在查找第一个正则表达式匹配之后结束查找，那么就由这个最佳的location提供请求处理。</li></ul><p>这里比较匹配描述的是解码URI，例如，在URI中的<code>%20</code>，将会匹配location中的<code></code>（空格）。  </p><p>命名location仅可以在location中使用。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="仅用于location中的指令"><a href="#仅用于location中的指令" class="headerlink" title="仅用于location中的指令"></a>仅用于location中的指令</h3><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160110145113840-384830365.png" alt=""></p><h3 id="其它指令"><a href="#其它指令" class="headerlink" title="其它指令"></a>其它指令</h3><p>另外，http部分的其他指令也可以在location中指定。</p><h3 id="try-files"><a href="#try-files" class="headerlink" title="try_files"></a>try_files</h3><p>指令<code>try_files</code>可以用在server部分，但是最常见的还是在location部分中。<code>try_files</code>指令将会按照给定它的参数列出的顺序进行尝试，第一个被匹配的将会被使用。  </p><p>它经常被用于从一个变量去匹配另一个可能的文件，然后将处理传递到一个命名location，看下面的例子：  </p><pre><code>location / {    try_files $url $url/ @mongrel;}location @mongrel {    proxy_pass http://appserver;}</code></pre><p>这里有一个隐含的目录索引，如果给定的URI作为一个文件没有被找到，那么处理将会通过代理被传递到appserver。</p><h2 id="location嵌套"><a href="#location嵌套" class="headerlink" title="location嵌套"></a>location嵌套</h2><p>除了以下前缀外，locations可以被嵌套。</p><ul><li>具有<code>=</code>前缀</li><li>命名location</li></ul><p>最佳时间表明正则表达式location被嵌套在基于字符串的location，看下面的例子：</p><pre><code>#首先进入根路径location / {    #符合/css路径的最佳匹配位置    location ^~ /css {        #匹配正则        location~* /css/.*\.css$ {        }    }}</code></pre><h1 id="完整的示例配置文件"><a href="#完整的示例配置文件" class="headerlink" title="完整的示例配置文件"></a>完整的示例配置文件</h1><p>以下示例是一个样本配置文件：  </p><pre><code>user www;worker_processes 12;error_log /var/log/nginx/error.log;pid /var/run/nginx.pid;events {    use /dev/poll;    worker_connections 2048;}http {    include mime.types;    default_type application/octet-stream;    sendfile on;    tcp_nopush on;    tcp_nodelay on;    keepalive_timeout 65;    server_name_hash_max_size 1024;    server {        listen 80;        return 444;    }    server {        listen 80;        server_name www.example.com;        location / {            try_files $url $url/ @mongrel;        }        location @mongrel {            proxy_pass http://127.0.0.1:8080;        }    }}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本章中，我们看到了如何构建Nginx的配置文件。模块化的本质值得思考，从某种意义上讲，Nginx本身也是模块化的。全局的配置区段负责各个方面，对于Nginx来说是一个整体。Nginx负责处理的每一种协议单独成为一个部分。我们还可以通过在这些协议配置内（http或者mail）指定server来定义每一个请求如何被处理，以便请求被路由到特定的IP地址和端口上。在http区段中，使用locations来匹配URI请求，这些locations可以嵌套使用，或者按照其他顺序使用，以确保请求被路由到正确的文件系统区域或者应用程序服务器。  </p><p>本章没有涵盖编译到二进制Nginx命令中各种模块提供的配置选项，这些额外的指令将会遍及本书的始终，因此特定的模块被用于解决一个问题。对于Nginx配置中的变量也没有解释，这些变量也将会在后边的内容中讨论。</p><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2016/01/10/nginx-note-config/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/01/10/nginx-note-config/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      基本配置格式、Nginx全局配置参数、使用include文件、Http的server部分、虚拟服务器部分、location－－在哪儿，什么时候，怎么样、mail的server部分、完整的示例配置文件
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Debian用户管理</title>
    <link href="http://yoursite.com/2016/01/09/debian-users/"/>
    <id>http://yoursite.com/2016/01/09/debian-users/</id>
    <published>2016-01-09T06:49:26.000Z</published>
    <updated>2018-10-28T11:37:51.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><h3 id="添加用户组"><a href="#添加用户组" class="headerlink" title="添加用户组"></a>添加用户组</h3><pre><code>groupadd group-name</code></pre><h3 id="添加用户-1"><a href="#添加用户-1" class="headerlink" title="添加用户"></a>添加用户</h3><pre><code>useradd -g group-name user-name</code></pre><h2 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h2><pre><code>passwd user-name</code></pre><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><pre><code>userdel user-name</code></pre><h2 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h2><h3 id="查看指定用户信息"><a href="#查看指定用户信息" class="headerlink" title="查看指定用户信息"></a>查看指定用户信息</h3><pre><code>id user-name</code></pre><h3 id="查看所有用户信息"><a href="#查看所有用户信息" class="headerlink" title="查看所有用户信息"></a>查看所有用户信息</h3><pre><code>cat /etc/passwd</code></pre><h2 id="设置sudo权限"><a href="#设置sudo权限" class="headerlink" title="设置sudo权限"></a>设置sudo权限</h2><pre><code>visudo</code></pre><p>找到<code>root    ALL=(ALL:ALL) ALL</code><br>下面添加<code>user-name    ALL=(ALL:ALL) ALL</code>  </p><h3 id="sudo无需密码"><a href="#sudo无需密码" class="headerlink" title="sudo无需密码"></a>sudo无需密码</h3><p>改成<br><code>user-name    ALL=NOPASSWD:ALL</code> </p><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2016/01/09/debian-users/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/01/09/debian-users/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      添加用户组/用户、设置密码、删除用户、查看所有用户、设置普通用户sudo权限。
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Nginx学习笔记（一）－Nginx及第三方模块安装</title>
    <link href="http://yoursite.com/2016/01/09/nginx-note-install/"/>
    <id>http://yoursite.com/2016/01/09/nginx-note-install/</id>
    <published>2016-01-09T05:33:33.000Z</published>
    <updated>2018-10-28T11:37:51.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>学习资料参考《精通Nginx》－－Dimitri Aivaliotis，陶利军译。<br>如有问题请联系<a href="mailto:wengyingjian@foxmail.com" target="_blank" rel="noopener">wengyingjian@foxmail.com</a></p><h1 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h1><h2 id="使用包管理器安装Nginx"><a href="#使用包管理器安装Nginx" class="headerlink" title="使用包管理器安装Nginx"></a>使用包管理器安装Nginx</h2><p><strong>Linux(debian)</strong></p><pre><code>sudo apt-get install nginx</code></pre><p><strong>Linux(rpm)</strong></p><pre><code>sudo yum install nginx</code></pre><p><strong>FreeBSD</strong></p><pre><code>sudo pkg_install -r nginx</code></pre><h3 id="Centos"><a href="#Centos" class="headerlink" title="Centos"></a>Centos</h3><p>1.创建文件添加yum配置  </p><pre><code>sudo vi /etc/yum.repos.d/nginx.repo[nginx]name=nginx repobaseurl=http://nginx.org/package/centos/6/$basearch/gpgcheck=0enabled=1</code></pre><p>2.执行命令安装nginx</p><pre><code>sudo yum install nginx</code></pre><p>由于笔者用的是debian(ubuntu)，所以对于centos的安装方法并没有测试过。。。只是搬的书上的。  </p><h3 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h3><p>1.通过从<a href="http://nginx.org/keys/nginx_signing.key" target="_blank" rel="noopener">http://nginx.org/keys/nginx_signing.key</a>下载Nginx并安装签名key，将该签名添加到系统的<code>apt keying</code> 中。  </p><pre><code>sudo apt-key add nginx_signing.key</code></pre><p>2.将nginx.org仓库追加到<code>/etc/apts/sources.list</code>文件末尾。  </p><pre><code>cat &quot;deb http://nginx.org/packages/debian/ squeeze nginx&quot; &gt;&gt; sources.listcat &quot;deb-src http://nginx.org/packages/debian/ squeeze nginx&quot; &gt;&gt; sources.list</code></pre><p>3.执行命令安装</p><pre><code>sudo apt-get updatesudo apt-get install nginx</code></pre><p>如果以上的方法无法安装成功，可以尝试用源代码安装。  </p><h2 id="从源代码编安装Nginx"><a href="#从源代码编安装Nginx" class="headerlink" title="从源代码编安装Nginx"></a>从源代码编安装Nginx</h2><h3 id="获取nginx源代码"><a href="#获取nginx源代码" class="headerlink" title="获取nginx源代码"></a>获取nginx源代码</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a>  </p><pre><code>cd ~ &amp;&amp; mkdir build/cd build &amp;&amp; wget http://nginx.org/download/nginx-1.8.0.tar.gz</code></pre><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><pre><code>tar -zxvf nginx-1.8.0.tar.gz</code></pre><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>构建目录为当前目录<code>~/build/nginx-1.8.0</code>，nginx安装路径为<code>/opt/nginx</code>  </p><pre><code>cd nginx-1.8.0 &amp;&amp; ./configure --prefix=/opt/nginx</code></pre><p>此时报错，因为一些模块未安装。<br>需要先安装模块，或者是指定模块的源代码、或者是跳过该模块的安装。  </p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>make &amp;&amp; sudo make install</code></pre><h3 id="其它环境的支持"><a href="#其它环境的支持" class="headerlink" title="其它环境的支持"></a>其它环境的支持</h3><h4 id="PCRE"><a href="#PCRE" class="headerlink" title="PCRE"></a>PCRE</h4><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160109152426215-1891784238.png" alt=""><br>PCRE : Perl Compatible Regular Expressions  </p><p>PCRE下载地址：<a href="ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/" target="_blank" rel="noopener">ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/</a>  </p><pre><code>wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.37.tar.gztar zxf pcre-8.37.tar.gzcd pcre-8.37 &amp;&amp; ./configuremake &amp;&amp; sudo make install</code></pre><p>再去编译nginx，其他问题：<br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160109153249481-1402262291.png" alt="">  </p><h4 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h4><pre><code>sudo apt-get install libssl-dev</code></pre><h3 id="通用配置选项"><a href="#通用配置选项" class="headerlink" title="通用配置选项"></a>通用配置选项</h3><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160109153712340-873775732.png" alt=""></p><h3 id="优化配置选项"><a href="#优化配置选项" class="headerlink" title="优化配置选项"></a>优化配置选项</h3><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160109153835465-1440385827.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160109153850793-858580787.png" alt=""></p><h2 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h2><pre><code>cd /opt/nginx &amp;&amp; sbin/nginx</code></pre><p>访问<a href="">http://host:80</a>  </p><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160109155103543-761296763.png" alt=""></p><h1 id="配置Web或者mail服务器"><a href="#配置Web或者mail服务器" class="headerlink" title="配置Web或者mail服务器"></a>配置Web或者mail服务器</h1><p>根据nginx构建目标，可以将其配置称一个Web加速器、Web服务器、邮件代理，或者是集所有为一体。  </p><h2 id="邮箱代理配置选项"><a href="#邮箱代理配置选项" class="headerlink" title="邮箱代理配置选项"></a>邮箱代理配置选项</h2><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160109160328356-2123374568.png" alt="">  </p><p>典型mail代理推荐配置：  </p><pre><code>./configure --with-mail --with-mail_ssl_module --with-openssl=openssl-1.0.1c</code></pre><h2 id="指定路径的配置选项"><a href="#指定路径的配置选项" class="headerlink" title="指定路径的配置选项"></a>指定路径的配置选项</h2><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160109160530825-967000378.png" alt="">  </p><h1 id="使用各种模块"><a href="#使用各种模块" class="headerlink" title="使用各种模块"></a>使用各种模块</h1><p>在nginx发布的版本中，除了http和mail模块意外，还有其它一些模块。这些模块在默认安装中没有被安装，但是可以在编译安装时适当地配置选项<code>--with-&lt;module-name&gt;_module</code>来启用相应的选项，如下表：<br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160109160928621-339915614.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160109160934481-1952351560.png" alt=""></p><p>以上所有这些模块都是建立在Http模块的基础之上的。  </p><p>网络加速器／代理推荐配置：  </p><pre><code>./configure --with-http_ssl_module --with-http_realip_module --with-http_geoip_module --with-http_stub_status_module --with-openssl=openssl-1.0.1c</code></pre><p>Web服务器推荐配置：  </p><pre><code>./configure --with-http_stub_status_module</code></pre><p>“不同之处在于他们面对的客户，处于Web加速角色时，会考虑到SSL请求的终结，也包括处理代理客户和基于客户来源决策。处于Web服务角色时，则仅需要提供默认文件访问能力。 我总是推荐启用<code>stub_status</code>模块，这是因为它提供了收集Nginx如何执行、对其度量的一个方法。”  </p><h2 id="不再使用的模块"><a href="#不再使用的模块" class="headerlink" title="不再使用的模块"></a>不再使用的模块</h2><p>有些http模块通常情况下时激活的，但是可以通过配置<code>--without-&lt;module-name&gt;_module</code>来禁用它们。  </p><p>禁用的配置选项：<br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160109161901106-1275493047.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160109161910075-962295421.png" alt=""></p><h1 id="查找并安装第三方模块"><a href="#查找并安装第三方模块" class="headerlink" title="查找并安装第三方模块"></a>查找并安装第三方模块</h1><p>方法步骤：</p><ol><li>定位你想要使用的模块（在<a href="http://github.com" target="_blank" rel="noopener">http://github.com</a>或者是<a href="http://wiki.nginx.org/3rdPartyModules" target="_blank" rel="noopener">http://wiki.nginx.org/3rdPartyModules</a>查找。</li><li>下载该模块。</li><li>解压缩源代码安装包。</li><li>如果有<code>README</code>文件，就阅读<code>README</code>文件，查看是否有依赖安装。</li><li>通过<code>/configure-add-module=&lt;path&gt;</code>选项配置使用该模块。</li></ol><p>安装详见：<a href="http://wiki.nginx.org/HttpLuaModule#Installation" target="_blank" rel="noopener">http://wiki.nginx.org/HttpLuaModule#Installation</a>  </p><h1 id="组合在一起"><a href="#组合在一起" class="headerlink" title="组合在一起"></a>组合在一起</h1><p>中间可能会遇到一些文件的权限问题，这些都比较简单，用sudo给对应的文件修改权限即可。这里就不提了。  </p><h2 id="首先一些环境："><a href="#首先一些环境：" class="headerlink" title="首先一些环境："></a>首先一些环境：</h2><pre><code>$ export BUILD_DIR=`pwd`$ export Nginx_INSTALLDIR=/opt/nginx$ export VAR_DIR=/home/www/tmp</code></pre><h2 id="第三方模块："><a href="#第三方模块：" class="headerlink" title="第三方模块："></a>第三方模块：</h2><h3 id="ngx-devel-kit"><a href="#ngx-devel-kit" class="headerlink" title="ngx_devel_kit"></a>ngx_devel_kit</h3><p><a href="https://github.com/simpl/ngx_devel_kit.git" target="_blank" rel="noopener">https://github.com/simpl/ngx_devel_kit.git</a><br>clone到<code>BUILD_DIR</code>下。 </p><h3 id="ngx-lua"><a href="#ngx-lua" class="headerlink" title="ngx_lua"></a>ngx_lua</h3><p><a href="https://github.com/openresty/lua-nginx-module.git" target="_blank" rel="noopener">https://github.com/openresty/lua-nginx-module.git</a><br>clone到<code>BUILD_DIR</code>下。  </p><p>其中<code>ngx_lua</code>需要<code>Lua Library</code><br><a href="http://stackoverflow.com/questions/10650904/build-nginx-with-lua-on-rpm-system" target="_blank" rel="noopener">http://stackoverflow.com/questions/10650904/build-nginx-with-lua-on-rpm-system</a><br>先安装<code>lua-devel</code>包：</p><pre><code>sudo apt-get install libluajit-5.1-dev</code></pre><h2 id="openssl与pcre"><a href="#openssl与pcre" class="headerlink" title="openssl与pcre"></a>openssl与pcre</h2><p>为了解除nginx与系统的openssl/pcre的耦合，这里使用指定sourceDir的方式来配置</p><h3 id="pcre"><a href="#pcre" class="headerlink" title="pcre"></a>pcre</h3><p>下载地址：<a href="ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/" target="_blank" rel="noopener">ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/</a>  </p><pre><code>cd $BUILD_DIR/../wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.37.tar.gztar zxf pcre-8.37.tar.gz</code></pre><h3 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h3><p>官网：<a href="https://www.openssl.org/source/" target="_blank" rel="noopener">https://www.openssl.org/source/</a><br>github地址：<a href="https://github.com/openssl/openssl.git" target="_blank" rel="noopener">https://github.com/openssl/openssl.git</a>  </p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre><code>./configure \ --prefix=${Nginx_INSTALLDIR} \ --user=www \ --group=www \ --http-client-body-temp-path=${VAR_DIR}/client_body_temp \ --http-proxy-temp-path=${VAR_DIR}/proxy_temp \ --http-fastcgi-temp-path=${VAR_DIR}/fastcgi_temp \ --without-http_uwsgi_module \ --without-http_scgi_module \ --without-http_browser_module \ --with-openssl=${BUILD_DIR}/../openssl-1.0.1q \ --with-pcre=${BUILD_DIR}/../pcre-8.37 \ --with-http_ssl_module \ --with-http_sub_module \ --with-http_flv_module \ --with-http_gzip_static_module \ --with-http_gunzip_module \ --with-http_secure_link_module \ --with-http_stub_status_module \ --add-module=${BUILD_DIR}/ngx_devel_kit \ --add-module=${BUILD_DIR}/lua-nginx-module</code></pre><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160109181830293-1428580256.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章介绍了各种Nginx的有效模块，通过编译你自己的二进制文件，你可以定制Nginx能够为你提供哪些功能。构建和安装软件对于你来说应该不会陌生，所以在创造一个构建环境或确保所有依赖关系都存在上不会花很多时间。一个Nginx的安装应该是按照你的需要，能够随时启用或禁用模块，正如你看到的，启用或者是禁用一个模块应该感到很容易。    </p><p>接下来我们将介绍几本的Nginx配置概述，以便感受一下在通常情况下Nginx是如何配置的。  </p><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2016/01/09/nginx-note-install/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/01/09/nginx-note-install/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      使用包管理器/源代码安装Nginx、配置Web/mail服务器、使用各种模块、查找安装第三方模块。
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建（二）-自动化及扩展功能</title>
    <link href="http://yoursite.com/2016/01/04/hexo-blog-helloWorld2/"/>
    <id>http://yoursite.com/2016/01/04/hexo-blog-helloWorld2/</id>
    <published>2016-01-04T02:31:04.000Z</published>
    <updated>2018-10-28T11:37:51.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在上一篇<a href="http://wengyingjian.github.io/2016/01/03/hexo-blog-helloWorld/" target="_blank" rel="noopener">Hexo博客搭建</a>中，我们已经通过Hexo让Github Page博客可以访问了。  </p><p>本篇将会介绍一些高级一些的功能。  </p><p>不过更多的还请参见官方文档：<br><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo中文文档</a><br><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">主题nexT文档</a></p><h2 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h2><p>现在开始写第一篇博客。  </p><h3 id="新建源文件"><a href="#新建源文件" class="headerlink" title="新建源文件"></a>新建源文件</h3><p>源文件都存放在<code>source</code>目录下：<br>博客的<code>.md</code>源文件存放在站点目录下的<code>source/_posts</code>文件夹下。  </p><p><strong>方法1:</strong><br>在<code>source/_posts</code>文件夹下新建<code>.md</code>，或者在该目录下再拷贝一份。<br><strong>方法2:</strong><br>在站点根目录下使用<code>hexo new filename</code>命令通过创建模板自动在<code>source/_posts</code> 文件夹下创建博客源文件，效果如下：<br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160104105229371-1091528992.png" alt="">  </p><p>还是推荐方法2的，因为能够使用模版来创建，模版文件为<code>scaffolds/post.md</code>可以编辑自己喜欢的模板。<br>带有类别，标签的模板如下：  </p><pre><code>title: {{ title }}description: {{ title }}date: {{ date }}tags: [tag1,tag2]categories: 2018年以前---</code></pre><h3 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h3><p>假设现在博客已经写好了，要发布。 </p><p>那么就需要做两件事情：<br>1.首先告诉hexo将自己的源文件转化成对应的<code>.html</code>文件，并且存放在<code>public</code>目录下。执行命令如下（站点目录下）：  </p><pre><code>hexo g</code></pre><p>2.然后再将<code>public</code>目录下的资源push到github，执行命令如下（从站点目录下过来）：</p><pre><code>cd publicgit add .git commit -m &quot;a&quot;git push </code></pre><h2 id="简化流程"><a href="#简化流程" class="headerlink" title="简化流程"></a>简化流程</h2><p>在上述步骤中，发布博客所需要执行的命令明显是有些过于繁琐了：多么简单的事啊，非得要执行这么多的命令。<br>而且其中的Git操作只是为了一个目的：将新的源文件放上去，都不需要版本控制的功能了，对于我来说只是一个仓库。  </p><p>所以，作为懒人，必须的自动化。<br>由于没怎么写过shell脚本，之前的java应用自动化部署工具也是用java写的。。。所以这次我还是准备用java写个jar包来执行。。<br>然而失败了，以我现在的功力，行不通。。。或者说是没找到API。  </p><h4 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h4><p>虽然没写过<code>.sh</code>脚本，但是linux的命令还是会敲的。<br>于是简单的脚本诞生了：配合上<code>$BLOG_HOME</code>环境变量，再将脚本文件添加至环境变量<code>PATH</code>中。<br><a href="https://github.com/wengyingjian/data/blob/master/script/blog" target="_blank" rel="noopener">blog脚本地址</a>  </p><p><code>~/.bash_profile</code>中添加的配置：</p><pre><code>#blogexport BLOG_HOME=&apos;/Users/wyj/git/wengyingjian.github.io&apos;    PATH=${PATH}:~/sh/blog/</code></pre><p>当然，我的blog文件位于<code>~/sh/blog/</code>。  </p><h4 id="脚本功能示例"><a href="#脚本功能示例" class="headerlink" title="脚本功能示例"></a>脚本功能示例</h4><ul><li><p>查看已有的博客文件：</p><pre><code>blog ls</code></pre></li><li><p>新建博客文件（同时还在自己打开了，贴心否。。）：</p><pre><code>blog new fileName</code></pre></li><li><p>删除博客文件(这里的文件都是不带<code>.md</code>后缀的)：</p><pre><code>blog rm fileName</code></pre></li><li><p>发布博客（生成文件并自动提交）</p><pre><code>blog deploy</code></pre></li><li><p>调试模式（文件修改了能够自动生成，可以边写边看<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>）：  </p><pre><code>blog debug</code></pre></li></ul><h2 id="博客扩展功能"><a href="#博客扩展功能" class="headerlink" title="博客扩展功能"></a>博客扩展功能</h2><h3 id="导航栏外部链接"><a href="#导航栏外部链接" class="headerlink" title="导航栏外部链接"></a>导航栏外部链接</h3><p>比如说我以前的博客在csdn，希望在导航栏上加上一个csdn的链接。 </p><p>由于我未找到使用超链接的方法，所以只能达到页面跳转而非新窗口打开的效果了。  </p><h4 id="添加导航菜单栏条目"><a href="#添加导航菜单栏条目" class="headerlink" title="添加导航菜单栏条目"></a>添加导航菜单栏条目</h4><p>打开主题配置文件<code>_config.yml</code>，找到<code>menu</code>一栏，添加一项即可：<br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160104113053981-1710580758.png" alt="">  </p><p>这个时候执行<code>blog deploy</code>，可以看到博客的导航栏变了，但并不是我们要的”csdn”，被强行加上了前缀有没有。。  </p><p>其实这个前缀是在找不到对应的映射的时候添加的，编辑主题配置文件<code>themes/next/languages/zh-Hans.yml</code>（当然这里你使用的是什么语言环境就改哪个配置文件），也是找到<code>menu</code>，添加中文简体环境下的显示：<br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160104113619246-165476254.png" alt="">  </p><p><strong>关于语言选择：</strong>这个在站点配置文件<code>_config.yml</code>中，通过<code>language</code>属性来指定，简体中文为<code>zh-Hans</code>。</p><h4 id="导航菜单栏跳转"><a href="#导航菜单栏跳转" class="headerlink" title="导航菜单栏跳转"></a>导航菜单栏跳转</h4><p>现在导航栏的显示应该是正常了，现在我们让他跳转：</p><p>还记得之前在主题配置文件<code>_config.yml</code>中添上的<code>menu.csdn:/csdn</code>。这就说明点了这个菜单以后，去找<code>source/csdn/index.md</code>这个源文件；或者说是在hexo生成html文件以后去找<code>public/csdn/index.html</code>。<br>贴上配置<code>index.md</code>源代码：  </p><pre><code>title: csdn/date: 2016-01-03 02:11:52type: &quot;csdn&quot;comments: falselayout: false---&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; // 以下方式直接跳转window.location.href=&apos;http://blog.csdn.net/q291611265&apos;;// 以下方式定时跳转&lt;/script&gt;  </code></pre><p><code>layout:false</code>是关键，告诉hexo不要再用任何的模板来包装我了，下面的内容就是生成后<code>html</code>文件的内容。  </p><h3 id="其它的"><a href="#其它的" class="headerlink" title="其它的"></a>其它的</h3><p>推荐一下：<br>站内搜索、网站统计、分享／评论栏 添加一下还是很不错的。<br>比较简单：<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/third-party-services.html</a><br><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2016/01/04/hexo-blog-helloWorld2/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/01/04/hexo-blog-helloWorld2/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      第一篇博客、自动化脚本、博客站点拓展功能：导航栏
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="helloWorld" scheme="http://yoursite.com/tags/helloWorld/"/>
    
      <category term="自动化工具" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建（一）－Github Page生效</title>
    <link href="http://yoursite.com/2016/01/03/hexo-blog-helloWorld/"/>
    <id>http://yoursite.com/2016/01/03/hexo-blog-helloWorld/</id>
    <published>2016-01-03T09:00:12.000Z</published>
    <updated>2018-10-28T11:37:51.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前的博客没有目录，无意之中又看到<a href="http://arccode.net/" target="_blank" rel="noopener">http://arccode.net/</a>的博客非常漂亮，所以就有了重构博客风格的想法，反正有价值的博客内容都能直接拷过来。  </p><p>但是我找遍了<a href="http://arccode.net/" target="_blank" rel="noopener">http://arccode.net/</a>的文章也没看到如何搭建的教程，无奈之下只好向作者发邮件求助。  </p><p>幸运的是一个小时不到博主就给我回邮件了，并且告诉我模板的地址：<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a>。再次感谢。  </p><p>跟着里面的教程一步步走，虽然中间遇到了很多的问题，但是最终博客还是搭建起来了。  </p><p>所以这里分享一下博客搭建的过程，以及常见的一些问题。希望对读者能够有所帮助。  </p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>点开<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a>，发现是个Github 仓库，于是先去看README：<br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160103171517823-1268664990.png" alt="">  </p><p>先去“在线预览”过把瘾，看看自己的博客会变成什么样的，果然效果是我满意的。果断点开“使用文档”开搞。 </p><h3 id="与教程不同的点"><a href="#与教程不同的点" class="headerlink" title="与教程不同的点"></a>与教程不同的点</h3><p>教程<a href="http://theme-next.iissnan.com/five-minutes-setup.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/five-minutes-setup.html</a> 中第一步就是安装主题，而且还是“定位到Hexo站点目录下”。<br>这显然是太快了，Hexo都还没安装了。  </p><h3 id="安装Hexo-1"><a href="#安装Hexo-1" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>Hexo 的中文文档：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a>  </p><p>要想安装Hexo需要两个前提条件：  </p><ol><li>安装Git</li><li>安装Node.js</li></ol><p>下面我针对Mac系统比较消息的谈谈安装的过程，其它系统我也没试过，只好各位自行google了。  </p><h4 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h4><p>git是不是Mac自带的我都忘了，反正写程序的话这个几乎是必备的了。<br>实在没有，还嫌麻烦的，可以下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a> 安装。  </p><h4 id="Node-js安装"><a href="#Node-js安装" class="headerlink" title="Node.js安装"></a>Node.js安装</h4><p>这个我的机器上没有，而且在安装的时候遇到了蛮大的问题。  </p><h5 id="安装方法1-安装程序"><a href="#安装方法1-安装程序" class="headerlink" title="安装方法1:安装程序"></a>安装方法1:安装程序</h5><p>先推荐一下绿色通道：下载<a href="https://nodejs.org/en/" target="_blank" rel="noopener">安装程序</a> 安装。</p><h5 id="安装方法2：命令行"><a href="#安装方法2：命令行" class="headerlink" title="安装方法2：命令行"></a>安装方法2：命令行</h5><p>这个需要用到wget，所以如果没有安装wget，那就先装一下。</p><h6 id="安装wget"><a href="#安装wget" class="headerlink" title="安装wget"></a>安装wget</h6><p><a href="http://coolestguidesontheplanet.com/install-and-configure-wget-on-os-x/" target="_blank" rel="noopener">http://coolestguidesontheplanet.com/install-and-configure-wget-on-os-x/</a><br>方法1:下载<a href="http://rudix.org/packages/wget.html" target="_blank" rel="noopener">安装程序</a>安装。<br>我的是10.11版本，下第一个就行了。  </p><p>方法2:源码编译<br>1.下载  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Downloads</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O http://ftp.gnu.org/gnu/wget/wget-1.15.tar.gz</span><br></pre></td></tr></table></figure><p>2.解压  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf wget-1.15.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> wget-1.15/</span><br></pre></td></tr></table></figure><p>3.配置安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>中途可能会报错：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure: error: --with-ssl was given, but GNUTLS is not available.</span><br></pre></td></tr></table></figure></p><p>wget需要SSL的支持，但是GNUTLS在大多数OS X系统上是没有的，所以就使用OpenSSL。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-ssl=openssl</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>完成了以后，wget就被安装到了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/bin/wget</span><br></pre></td></tr></table></figure><p>4.清除源代码与压缩包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/Downloads/wget*</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Downloads</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://ftp.gnu.org/gnu/wget/wget-1.15.tar.gz</span><br></pre></td></tr></table></figure><p>方法3:<a href="http://coolestguidesontheplanet.com/installing-homebrew-os-x-yosemite-10-10-package-manager-unix-apps/" target="_blank" rel="noopener">HomeBrew</a>方式安装。  </p><h6 id="命令行安装Node-js"><a href="#命令行安装Node-js" class="headerlink" title="命令行安装Node.js"></a>命令行安装Node.js</h6><p>安装Node.js要走的几步：</p><p>安装nvm<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure><p>完成后重启终端，再安装Node.js。。一定要重启。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install 4</span><br></pre></td></tr></table></figure></p><p>首先，第一步没有出问题。<br>第二步用wget，安装好了wget应该也没啥问题。<br>第三步如果中途网络失败了多试几次。。  </p><h4 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>如果中途网络失败了多试几次。<br>安装的时候可能会报错，应该是权限的问题，前面加上<code>sudo</code>就行。   </p><p>如果出现什么我这没提到的错误可以在下方留言，因为我在安装的时候没有截图，很多错误不好描述。  </p><h3 id="测试Hexo"><a href="#测试Hexo" class="headerlink" title="测试Hexo"></a>测试Hexo</h3><p>前提得是hexo安装好了。<br>选一个用来存放博客的目录：</p><blockquote><p>我的目录选在了<code>~/git/wengyingjian.github.io/</code>。<br>千万不要被我这个站点的名称所迷惑了，当初叫了这个名字也是因为自己不知道，现在才发现不合情理。应该放在<code>~/hexo/blog/</code>下比较好。。 </p></blockquote><p>然后在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>就跟<code>git init</code>一样，将需要的一些文件啥的都创建好了。</p><p>目录结构就像是这个仓库：<a href="https://github.com/wengyingjian/wengyingjian.github.io-hexo.demo.git" target="_blank" rel="noopener">https://github.com/wengyingjian/wengyingjian.github.io-hexo.demo.git</a>  </p><p>然后运行一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure><p><code>hexo s</code>就是<code>hexo server</code>的意思。  </p><p><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160103181733964-1367032438.png" alt=""><br>接下来就可以在浏览器访问<a href="http://127.0.0.1:4000" target="_blank" rel="noopener">http://127.0.0.1:4000</a>  </p><p>###关于权限的一些问题<br>在安装Hexo的时候，有些时候会报错，因为权限不足。<br>遇到这种情况当然是通过在命令前面加上<code>sudo</code>来解决了。  </p><p>我之前这样做的时候又引发了新的问题：在站点目录下很多自动创建文件的所有者为<code>root</code>，这样搞的我们每次执行相关的命令都要用到<code>sudo</code>。</p><p>在平常操作<code>hexo s</code>,<code>hexo g</code>,<code>hexo new</code>的时候，并不会涉及到站点以外的文件，如果还是此时报出了权限问题，我们可以将站点跟路径下所有文件的所有者改为当前用户： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R user .</span><br></pre></td></tr></table></figure><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><h3 id="站点文件"><a href="#站点文件" class="headerlink" title="站点文件"></a>站点文件</h3><p>站点跟目录的文件应该是这个样子的<br><img src="http://images2015.cnblogs.com/blog/842598/201601/842598-20160103182724917-1851212629.png" alt=""><br>上图中的一些文件目录可能你现在会没有，但是也差不多。</p><p>简要解释下：  </p><ol><li><code>_config.yml</code>：主要配置文件，刚才生成的”<a href="http://127.0.0.1:4000&quot;站点重要的配置信息全在这了。" target="_blank" rel="noopener">http://127.0.0.1:4000&quot;站点重要的配置信息全在这了。</a>  </li><li>db.json：一些数据存放的地方，不用数据库，用json存。</li><li>debug.log:刚才以debug模式启动的，日志信息就在这了。</li><li>node_modules:这个太复杂，不管它</li><li>package.json:关于hexo的一些说明，如版本啊、插件等元数据。</li><li><code>public</code>:生成的站点，我们要访问，其实访问的html、css、js都在这里面了。</li><li>scaffolds:存放一些模版，后面再说。</li><li><code>source</code>：写博客，博客的源代码就放在这个里面了。</li><li><code>themes</code>：上面加阴影的是比较重要的，至于themes，下面说。  </li></ol><h3 id="Themes"><a href="#Themes" class="headerlink" title="Themes"></a>Themes</h3><p>themes文件夹下存放的就是主体，打开可以看到里面有一个叫做<code>langscape</code>的主体。之前在”<a href="http://127.0.0.1:4000&quot;看到的那套皮肤就是langscape的主题。" target="_blank" rel="noopener">http://127.0.0.1:4000&quot;看到的那套皮肤就是langscape的主题。</a></p><p>现在，我们要<strong>换主题</strong>,换成<code>nexT</code>主题。  </p><p>回到教程：<a href="http://theme-next.iissnan.com/five-minutes-setup.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/five-minutes-setup.html</a>  </p><h4 id="下载nexT主题"><a href="#下载nexT主题" class="headerlink" title="下载nexT主题"></a>下载nexT主题</h4><p>其实就是用git克隆到本地。<br>克隆到哪呢？就放在与<code>langscape</code>同级的目录。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> your-hexo-site</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><h4 id="使用nexT主题"><a href="#使用nexT主题" class="headerlink" title="使用nexT主题"></a>使用nexT主题</h4><p>告诉hexo，给我配上nexT的皮肤：<br>找到站点目录下的<code>_config.yml</code>，将<code> theme</code>的值改为<code>next</code>。  </p><h4 id="验证nexT主题"><a href="#验证nexT主题" class="headerlink" title="验证nexT主题"></a>验证nexT主题</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure><p>访问<a href="http://127.0.0.1:4000" target="_blank" rel="noopener">http://127.0.0.1:4000</a>  </p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>在站点跟目录下，有个配置文件叫做<code>_config.yml</code>；在主题目录下，也有一个配置文件叫做<code>_config.yml</code>。<br>为了方便区分，我们称前者为“站点配置文件”，后者为“主题配置文件”。  </p><h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><p>略<br>参考<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a></p><h2 id="第三方服务"><a href="#第三方服务" class="headerlink" title="第三方服务"></a>第三方服务</h2><p>略<br>参考<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a></p><h2 id="生效Github博客"><a href="#生效Github博客" class="headerlink" title="生效Github博客"></a>生效Github博客</h2><p>现在站点、主题基本是有个样子了。<br>先不去计较它的样子，让浏览器能够在Github博客上访问到，然后再慢慢去配置、丰富。  </p><h3 id="github创建仓库"><a href="#github创建仓库" class="headerlink" title="github创建仓库"></a>github创建仓库</h3><p>在github新建一个仓库。  </p><p>比如说的我github地址为<a href="http://github.com/wengyingjian" target="_blank" rel="noopener">http://github.com/wengyingjian</a>，那么我的仓库名称就叫做<code>wengyingjian.github.io</code>，对应的网址就是<a href="http://wengyingjian.github.io" target="_blank" rel="noopener">http://wengyingjian.github.io</a>。  </p><h3 id="上传博客内容到github"><a href="#上传博客内容到github" class="headerlink" title="上传博客内容到github"></a>上传博客内容到github</h3><p>应该还记得，我的站点跟路径是<code>~/git/wengyingjian.github.io</code>。  </p><p>但是，这并不是要上传文件的所在路径；这也是我之前犯的一个错。  </p><p>那么要上传的内容在哪呢？这个我也找了好久，因为教程上并没有。  </p><p><strong>后来发现是在<code>public</code>文件夹下。</strong>  </p><p>public文件夹下的文件资源已经是完全可用的了，以index.html为入口。所以把这个文件夹放上去是没有问题的。  </p><p>我的<code>site_dir</code>为<code>~/git/wengyingjian.github.io/</code>，就以我的为例。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/git/wengyingjian.github.io</span><br><span class="line"><span class="built_in">cd</span> public</span><br><span class="line">git init</span><br><span class="line">git remote add origin xxxx//github仓库地址</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"initial commit"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>此时访问<a href="http://wengyingjian.github.io" target="_blank" rel="noopener">http://wengyingjian.github.io</a>应该就不是404了。  </p><p>更多的在下一节说。<br>大多数问题其实都能够在<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a>中看文档解决。  </p><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2016/01/03/hexo-blog-helloWorld/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/01/03/hexo-blog-helloWorld/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      Hexo博客搭建简要教程：快速搭建，完成站点可用
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="helloWorld" scheme="http://yoursite.com/tags/helloWorld/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Rabbitmq（六）－Topics</title>
    <link href="http://yoursite.com/2016/01/02/rabbitmq-topics/"/>
    <id>http://yoursite.com/2016/01/02/rabbitmq-topics/</id>
    <published>2016-01-01T16:00:00.000Z</published>
    <updated>2018-10-28T11:37:51.927Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自：<a href="https://www.rabbitmq.com/tutorials/tutorial-five-java.html" target="_blank" rel="noopener">https://www.rabbitmq.com/tutorials/tutorial-five-java.html</a><br>整理过的源代码(java-maven,workqueues-package)：<a href="https://github.com/wengyingjian/rabbitmq-tutorial.git" target="_blank" rel="noopener">https://github.com/wengyingjian/rabbitmq-tutorial.git</a>  </p><h2 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h2><p>(通过java客户端实现)  </p><p>在<a href="http://wengyingjian.github.io/2016/01/01/rabbitmq-routing/" target="_blank" rel="noopener">前面的教程</a>中我们改进了日志输出系统，将<code>fanout</code>的路由模式改为<code>direct</code>，从而实现了消费者端可选择的控制消息日志。  </p><p>但是，<code>direct</code>类型也是有缺陷的：不能以一种标准来路由，只能指定具体的key。  </p><p>在日志系统中，我们需要收集的并不仅仅是程序报出的问题，更多的是需要跟踪到导致问题的根源。这可能让我们想到unix日志工具<code>syslog</code>，它的能收集到来自<code>onfo/warn/crit..</code>,<code>auth/crom/kern…</code>两处的日志。 </p><p>这样一来就很灵活了：我们可以选择要查看的日志的来源。  </p><p>要达到这个效果，就得学习一个新的、稍微复杂一些的路由器类型<code>topic</code>。</p><h3 id="Topic交换机"><a href="#Topic交换机" class="headerlink" title="Topic交换机"></a>Topic交换机</h3><p>发送至<code>topic</code>类型的交换机不是需要一个明确的<code>routing_key</code>，而是一些以<code>.</code>来分隔开的字符串，最好是能够说明message一些特征的单词，见名知意嘛。比如说：<code>stock.usd.nyse</code>,<code>nyse.vmw</code>,<code>quick.orange.rabbit</code>都是符合规范的。<code>routing_key</code>中放几个单词都是随便的，想要几个要几个，但是要求是总的大小要在255B以下。  </p><p>另外还要有<code>binding key。<code>topic</code>交换机背后的逻辑跟<code>direct</code>其实是非常相似的：带有指定<code>routing key的消息会被路由到所有所有与其<code>binding key匹配的队列中去。不同之处在于：  </code></code></code></p><blockquote><p><code>*</code>（星号）可以代表任何一个单词<br><code>#</code>（井号）可以代表任何0个或多个单词</p></blockquote><p>举例说明：<br><img src="https://www.rabbitmq.com/img/tutorials/python-five.png" alt=""><br>上图所示，我们要发送所有消息都是与动物相关的。这些消息的<code>routing key</code>由3个单词（2个点）组成。其中第一个单词代表动物的速度，第二个代表颜色，第三个代表类型：<code><speed>.<colour>.<species></species></colour></speed></code>  </p><p>然后创建了三种绑定：Q1-<code> <em>.orange. </em></code>;Q2<code> <em>. </em>.rabbit</code>;Q3<code>lazy.#</code>  </p><p>然后这些<code>binding key</code>的大致意思就是：  </p><blockquote><p>Q1:与所有颜色为<code>orange</code>的动物打交道。<br>Q2:与所有品种为<code>rabbit</code>的动物打交道。<br>Q3:与所有速度<code>lazy</code>的动物打交道。</p></blockquote><p>如果一个<code>routing key</code>为<code>quick.orange.rabbit</code>的消息发送出去，那么它会被Q1，Q2两个队列都接收到;<code>lazy.orange.elephant</code>会被Q1,Q2所接收。而<code>quick.orange.fox</code>只能被Q1接收，<code>lazy.brown.fox</code>只能被Q2接收。<code>lazy.pink.rabbit</code>虽然匹配上了Q2两次，但是只会发送一次到Q2，<code>quick.brown.fox</code>没找到匹配的自然就被丢弃了。  </p><p>如果<code>rounting key</code>不符合上面<code>binding key</code>的格式呢？比如说<code> orange </code>和<code>quick.orange.male.rabbit</code>，它们是会被全部丢弃的，因为不匹配。  </p><p><code>lazy.orange.male.rabbit</code>这个虽然有4个单词，但是它确是与<code>lazy.#</code>匹配，所以它就能够被发送到Q2中去。  </p><h5 id="Topic类型的交换机"><a href="#Topic类型的交换机" class="headerlink" title="Topic类型的交换机"></a>Topic类型的交换机</h5><p>他和其它交换机一样，只不过是多加了模式匹配的功能，从而更加强大了。  </p><p>当一个队列的<coed>binding key 为<code>#</code>时：匹配所有的<code>routing_key</code>类型的消息，就跟<code>fanout</code>类型的交换机功能一样了。  </coed></p><p>如果<code>*</code>,<code>#</code>都没有在<code>binding key</code>中用到时，那么它就跟<code>direct</code>类型的交换机功能一样的。</p><h3 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h3><p>将<code> topic </code>类型的交换机运用到日志输出系统中，把日志的格式定为<code><facility>.<severity></severity></facility></code>。  </p><p><a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/EmitLogTopic.java" target="_blank" rel="noopener"> EmitLogTopic.java</a></p><pre><code>public class EmitLogTopic {    private static final String EXCHANGE_NAME = &quot;topic_logs&quot;;    public static void main(String[] argv)                  throws Exception {        ConnectionFactory factory = new ConnectionFactory();        factory.setHost(&quot;localhost&quot;);        Connection connection = factory.newConnection();        Channel channel = connection.createChannel();        channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;);        String routingKey = getRouting(argv);        String message = getMessage(argv);        channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes());        System.out.println(&quot; [x] Sent &apos;&quot; + routingKey + &quot;&apos;:&apos;&quot; + message + &quot;&apos;&quot;);        connection.close();    }    //...}</code></pre><p><a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/ReceiveLogsTopic.java" target="_blank" rel="noopener">ReceiveLogsTopic.java</a></p><pre><code>import com.rabbitmq.client.*;import java.io.IOException;public class ReceiveLogsTopic {  private static final String EXCHANGE_NAME = &quot;topic_logs&quot;;  public static void main(String[] argv) throws Exception {    ConnectionFactory factory = new ConnectionFactory();    factory.setHost(&quot;localhost&quot;);    Connection connection = factory.newConnection();    Channel channel = connection.createChannel();    channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;);    String queueName = channel.queueDeclare().getQueue();    if (argv.length &lt; 1) {      System.err.println(&quot;Usage: ReceiveLogsTopic [binding_key]...&quot;);      System.exit(1);    }    for (String bindingKey : argv) {      channel.queueBind(queueName, EXCHANGE_NAME, bindingKey);    }    System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);    Consumer consumer = new DefaultConsumer(channel) {      @Override      public void handleDelivery(String consumerTag, Envelope envelope,                                 AMQP.BasicProperties properties, byte[] body) throws IOException {        String message = new String(body, &quot;UTF-8&quot;);        System.out.println(&quot; [x] Received &apos;&quot; + envelope.getRoutingKey() + &quot;&apos;:&apos;&quot; + message + &quot;&apos;&quot;);      }    };    channel.basicConsume(queueName, true, consumer);  }}</code></pre><h5 id="运行参数说明"><a href="#运行参数说明" class="headerlink" title="运行参数说明"></a>运行参数说明</h5><p>接收所有的日志：<code> ReceiveLogsTopic #</code><br>接收<code>kern</code>日志：<code> ReceiveLogsTopic  kern. <em></em></code><br>接收<code> critical </code>日志：<code> ReceiveLogsTopic .critical</code><br>创建多个绑定：<code> ReceiveLogsTopic  kern. <em>  </em>.critical</code>  </p><p>发送一条<code>routing key</code>为<code>kern.critical</code>的消息：<code>EmitLogTopic kern.critical A critical kernel error</code>  </p><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2015/01/02/rabbitmq-topics/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/01/02/rabbitmq-topics/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      Rabbitmq Topics：介绍一种新的交换机类型：topic
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="rabbitmq" scheme="http://yoursite.com/tags/rabbitmq/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Rabbitmq（七）－RPC</title>
    <link href="http://yoursite.com/2016/01/02/rabbitmq-rpc/"/>
    <id>http://yoursite.com/2016/01/02/rabbitmq-rpc/</id>
    <published>2016-01-01T16:00:00.000Z</published>
    <updated>2018-10-28T11:37:51.925Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自：<a href="https://www.rabbitmq.com/tutorials/tutorial-six-java.html" target="_blank" rel="noopener">https://www.rabbitmq.com/tutorials/tutorial-six-java.html</a><br>整理过的源代码(java-maven,workqueues-package)：<a href="https://github.com/wengyingjian/rabbitmq-tutorial.git" target="_blank" rel="noopener">https://github.com/wengyingjian/rabbitmq-tutorial.git</a>  </p><h2 id="远程方法调用（RPC）"><a href="#远程方法调用（RPC）" class="headerlink" title="远程方法调用（RPC）"></a>远程方法调用（RPC）</h2><p>(通过java客户端实现)  </p><p>在<a href="http://wengyingjian.github.io/2015/12/30/rabbitmq-workqueues/" target="_blank" rel="noopener">Rabbitmq（三）－Work Queues</a>中我们通过工作队列分发实现了多个消费者分担处理任务的功能。  </p><p>但是，如果我们执行的任务是有返回结果的，而且我们还需要这个结果呢？这种情况就有点不同了，在术语上我们称之为远程方法调用或者是RPC。</p><p>在这篇教程中，我们准备实现一个远程调用的功能：一个客户端，还有一个可扩展的RPC服务器。然而我们手头并没有啥需要返回结果的需求，只好模拟一个了：让RPC服务器返回Fibonacci数列。  </p><h5 id="客户端接口"><a href="#客户端接口" class="headerlink" title="客户端接口"></a>客户端接口</h5><p>要说明RPC服务器的工作原理，我们还需要创建一个简单的客户端接口。对外暴露一个<code>call</code>方法，然后调用这个<code>call</code>方法－－阻塞一段时间，直到接收到服务器的返回结果。  </p><pre><code>FibonacciRpcClient fibonacciRpc = new FibonacciRpcClient();   String result = fibonacciRpc.call(&quot;4&quot;);System.out.println( &quot;fib(4) is &quot; + result);</code></pre><p><strong>关于RPC需要注意的</strong><br>虽然RPC调用在计算机领域已经再平常不过了，但是如果程序员不知道一个方法的调用到底是本地调用还是（速度较慢的）远程调用的时候，可能就要出问题了。上述的这种情况会导致系统的不可预知性，而且还会给程序调试带来很大的麻烦。乱用、滥用RPC会使得程序的可维护性变的非常的差。  </p><p>所以，可以考虑一下如下的建议：  </p><blockquote><p>始终要明确一个方法的调用是本地调用还是远程调用。<br>给自己的代码写文档。让各个组件之间的依赖关系变的清晰明了。<br>做好异常处理：如果远程调用的服务挂了，或者是执行超时了该如何处理。  </p></blockquote><p>你也可以尝试使用异步管道来取代RPC－－当任务执行完成的时候自动将结果推送到下一个运行环境之中。  </p><h5 id="回调队列"><a href="#回调队列" class="headerlink" title="回调队列"></a>回调队列</h5><p>总的来说，通过RabbitMQ的RPC还是比较简单的：客户端将请求消息发送过去，服务器将执行结果返回回来。为了能够接收这个服务器处过来的返回结果，我们发送过去的消息就需要是带有回调信息的。</p><pre><code>callbackQueueName = channel.queueDeclare().getQueue();BasicProperties props = new BasicProperties                            .Builder()                            .replyTo(callbackQueueName)                            .build();channel.basicPublish(&quot;&quot;, &quot;rpc_queue&quot;, props, message.getBytes());// ... then code to read a response message from the callback_queue ...</code></pre><p><strong>消息属性</strong><br>AMQP协议预定义了14个消息（message）携带的属性。但是除了以下的一些属性，其它的很少被用到：  </p><blockquote><p><code> deliveryMode </code>:将消息标记为持久态（值为2）或者是瞬时态（其它任何值）。有可能你还记得在<a href="http://wengyingjian.github.io/2015/12/30/rabbitmq-workqueues/" target="_blank" rel="noopener">Rabbitmq（三）－Work Queues</a>中有提到过。<br><code> contentType </code>:用于说明编码的格式。比如说使用Json的格式，那么可以设置为：<code> application/json </code>。<br><code> replyTo </code>:通常用于给回调队列命名。<br><code> correlationId </code>:用于与请求的返回结果相关联。  </p></blockquote><p>写代码的时候需要引用如下：  </p><pre><code>import com.rabbitmq.client.AMQP.BasicProperties;</code></pre><h5 id="Correlation-Id"><a href="#Correlation-Id" class="headerlink" title="Correlation Id"></a>Correlation Id</h5><p>我们希望在所有的远程调用上都加上返回结果。然而这样做并不是很合理，还好有个更好的方法－－给它们都设置一个回调队列。  </p><p>这就产生了一个新的问题，队列得到了返回结果以后并不知道这个结果所属的请求者是谁。这个时候<code> correlationId </code>就该出马了。我们把每个请求的<code> correlationId </code>设置一个唯一的值，然后得到返回结果的时候就能拿到这个值，由此就能给返回结果匹配上对应的请求者了。当<code> correlationId </code>的值未知的时候，通常我们会把这个消息丢弃掉－－因为它不属于任何的请求。  </p><p>哪有可能你就要问了，为什么我们要在回调队列中把未知的消息给丢弃掉，而不是报错呢？这个就涉及到服务器竞争的问题了，如果碰巧遇到RPC服务器在我们收到了返回结果，但是还未给请求发送<code>ack</code>反馈的时候挂掉了。这种情况下服务器重启后请求会再次发送，所以我们的客户端就应该处理好返回结果重复的情况。  </p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p><img src="https://www.rabbitmq.com/img/tutorials/python-six.png" alt="">  </p><p>RPC的工作流程：  </p><blockquote><p>客户端开启了后，创建了一个匿名的，唯一的回调队列。<br>为了能够远程调用，客户端发送的消息需要带有2个参数：<code>replyTo</code>，设置回调的队列；<code>correlationId</code>，给每个请求设置唯一的标示。<br>将请求发送给<code>rpc_queue</code>队列。<br>RPC任务执行者（即<code>server</code>）监听该队列，等队列的请求过来的时候，它就将处理的结果返回给客户端，通过<code>replyTo</code>属性指定的那个队列。<br>客户端等待回调队列返回的数据。当接收到消息时，会先检查<code>correlationId</code>属性，如果找到了匹配上的请求，那么就将结果返回给该应用。 </p></blockquote><h3 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h3><p>Fibonacci任务：  </p><pre><code>private static int fib(int n) throws Exception {    if (n == 0) return 0;    if (n == 1) return 1;    return fib(n-1) + fib(n-2);}</code></pre><p>我们的Fibonacci函数假定所有的输入都是正整数（别指望他能够计算太大的数字，因为递归会让栈溢出的）。  </p><p><a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/RPCServer.java" target="_blank" rel="noopener">RPCServer.java</a>  </p><pre><code>private static final String RPC_QUEUE_NAME = &quot;rpc_queue&quot;;ConnectionFactory factory = new ConnectionFactory();factory.setHost(&quot;localhost&quot;);Connection connection = factory.newConnection();Channel channel = connection.createChannel();channel.queueDeclare(RPC_QUEUE_NAME, false, false, false, null);channel.basicQos(1);QueueingConsumer consumer = new QueueingConsumer(channel);channel.basicConsume(RPC_QUEUE_NAME, false, consumer);System.out.println(&quot; [x] Awaiting RPC requests&quot;);while (true) {    QueueingConsumer.Delivery delivery = consumer.nextDelivery();    BasicProperties props = delivery.getProperties();    BasicProperties replyProps = new BasicProperties                                     .Builder()                                     .correlationId(props.getCorrelationId())                                     .build();    String message = new String(delivery.getBody());    int n = Integer.parseInt(message);    System.out.println(&quot; [.] fib(&quot; + message + &quot;)&quot;);    String response = &quot;&quot; + fib(n);    channel.basicPublish( &quot;&quot;, props.getReplyTo(), replyProps, response.getBytes());    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);}</code></pre><p>服务器的代码是比较直接的：  </p><blockquote><p>老规矩，先创建连接(Connection)、通道(Channel)，声明队列(Queue)。<br>有些时候需要运行多个服务器进程，为了保证多个服务器能够比较均衡的处理任务，还需要通过<code>channel.basicQos</code>设置<code> prefetchCount</code>。<br>通过<code> basicConsume</code>来进入队列，然后就开始跑<code>while</code>循环来等待返回结果出来，好进行下一步的工作。  </p></blockquote><p><a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/RPCClient.java" target="_blank" rel="noopener">RPCClient.java</a>  </p><pre><code>private Connection connection;private Channel channel;private String requestQueueName = &quot;rpc_queue&quot;;private String replyQueueName;private QueueingConsumer consumer;public RPCClient() throws Exception {    ConnectionFactory factory = new ConnectionFactory();    factory.setHost(&quot;localhost&quot;);    connection = factory.newConnection();    channel = connection.createChannel();    replyQueueName = channel.queueDeclare().getQueue();     consumer = new QueueingConsumer(channel);    channel.basicConsume(replyQueueName, true, consumer);}public String call(String message) throws Exception {         String response = null;    String corrId = java.util.UUID.randomUUID().toString();    BasicProperties props = new BasicProperties                                .Builder()                                .correlationId(corrId)                                .replyTo(replyQueueName)                                .build();    channel.basicPublish(&quot;&quot;, requestQueueName, props, message.getBytes());    while (true) {        QueueingConsumer.Delivery delivery = consumer.nextDelivery();        if (delivery.getProperties().getCorrelationId().equals(corrId)) {            response = new String(delivery.getBody());            break;        }    }    return response; }public void close() throws Exception {    connection.close();}</code></pre><p>客户端代码略微的有点复杂：  </p><blockquote><p>开启连接(Connnection)、通道(Channel)，另外还需要声明一个用于答复的唯一的队列(Queue)。<br>监听回调的队列，以便有结果返回时的感知。<br><code>call</code>方法调用意味着开启RPC请求。<br>首先，生成一个唯一的<code>correlationId</code>，并且保存下来－－后面的<code>while</code>循环会通过它来寻找合适的返回结果。<br>然后将消息给发送出去，消息需要带有两个属性：<code>reployTo</code>和<code>correlationId</code>。<br>这个时候就只需要等待了，直到有匹配的返回信息。<br><code>while</code>循环的内容是非常简单的：对与所有过来的请求都检查一下<code>correlationId</code>是否我们要的那个，如果是的话，就将结果保存下来。<br>最终，将得到的结果返回给用户。  </p></blockquote><p>客户端请求：  </p><pre><code>RPCClient fibonacciRpc = new RPCClient();System.out.println(&quot; [x] Requesting fib(30)&quot;);   String response = fibonacciRpc.call(&quot;30&quot;);System.out.println(&quot; [.] Got &apos;&quot; + response + &quot;&apos;&quot;);fibonacciRpc.close();</code></pre><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2015/01/02/rabbitmq-topics/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/01/02/rabbitmq-topics/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      Rabbitmq rpc：远程方法调用
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="rabbitmq" scheme="http://yoursite.com/tags/rabbitmq/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>远程调用与本地调用</title>
    <link href="http://yoursite.com/2016/01/02/hessianrpc-%E8%B0%83%E7%94%A8%E4%B8%8E%E6%9C%AC%E5%9C%B0%E8%B0%83%E7%94%A8%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>http://yoursite.com/2016/01/02/hessianrpc-调用与本地调用的比较/</id>
    <published>2016-01-01T16:00:00.000Z</published>
    <updated>2018-10-28T11:37:51.899Z</updated>
    
    <content type="html"><![CDATA[<p>占坑</p><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2015/01/02/rabbitmq-topics/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/01/02/rabbitmq-topics/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      Rabbitmq Topics：介绍一种新的交换机类型：topic
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="rabbitmq" scheme="http://yoursite.com/tags/rabbitmq/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Rabbitmq（五）－Routing</title>
    <link href="http://yoursite.com/2016/01/01/rabbitmq-routing/"/>
    <id>http://yoursite.com/2016/01/01/rabbitmq-routing/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2018-10-28T11:37:51.924Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自：<a href="https://www.rabbitmq.com/tutorials/tutorial-four-java.html" target="_blank" rel="noopener">https://www.rabbitmq.com/tutorials/tutorial-four-java.html</a><br>整理过的源代码(java-maven,workqueues-package)：<a href="https://github.com/wengyingjian/rabbitmq-tutorial.git" target="_blank" rel="noopener">https://github.com/wengyingjian/rabbitmq-tutorial.git</a>  </p><h3 id="订阅-发布"><a href="#订阅-发布" class="headerlink" title="订阅/发布"></a>订阅/发布</h3><p>(通过java客户端实现)  </p><p>在<a href="http://wengyingjian.github.io/2015/12/31/rabbitmq-publish-subscribe/" target="_blank" rel="noopener">前面的教程</a>中我们完成了一个简单的日志输出系统，实现了将消息广播给多个订阅者的功能。  </p><p>在本篇教程中，我们在之前的基础上添加一些有趣的特性－－让订阅着可以选择只收到其中一部分的消息。举个例子：我们向屏幕输出所有的日志信息的同时，选择把错误的信息保存到硬盘上。  </p><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>在之前的例子中，已经有用过绑定了，代码如下：</p><pre><code>channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;);</code></pre><p>“绑定”其实就是交换机与队列的一个对应关系。也可以这样理解：某个队列只对它绑定了的路由器过来的信息感兴趣。  </p><p>绑定需要一个额外的<code>routingKey</code>参数，为了避免与<code>basic_publish</code>产生混淆，下面就称它为<code>binding key</code>。下面看下<code>binding key</code>是如何创建的：</p><pre><code>channel.queueBind(queueName, EXCHANGE_NAME, &quot;black&quot;);</code></pre><p><code>binding key</code>作用还得取决于交换机，因为有的交换机回去寻找对于<code>binding key</code>的队列，而我们之前用的例子（fanout类型的交换机）根据无视这个值。  </p><h3 id="直接交换"><a href="#直接交换" class="headerlink" title="直接交换"></a>直接交换</h3><p>与之前日志输出系统相比较，现在要做的就是实现一个消息的过滤器，通过它们各自的需求来过滤指定类型的消息。还是上面的例子：我们需要通过过滤得到日志中是错误的消息，把它们给写到硬盘上，这样可以避免太多普通日志来浪费硬盘的空间。  </p><p>之前用的是<code>fanout</code>交换机，这种交换机只能处理一些简单的广播事件，不够灵活。  </p><p>利用图示解决方案：<br><img src="https://www.rabbitmq.com/img/tutorials/direct-exchange.png" alt=""><br>这里交换机X的类型是<code>direct</code>的，它绑定了2个队列：第一个队列Q1是以<code>binding key=orange</code>的设置绑定的；第二个队列Q2是以<code>binding key=black+green</code>的设置绑定的。  </p><p>这样子设定的话，如果设置routing key为<code>orange</code>，那么就会路由到Q1，如果设置routing key为<code>black</code>或是<code>green</code>都会路由到Q2。其它的消息那就都被丢弃了。  </p><h3 id="多绑定"><a href="#多绑定" class="headerlink" title="多绑定"></a>多绑定</h3><p><img src="https://www.rabbitmq.com/img/tutorials/direct-exchange-multiple.png" alt=""><br>一个binding key绑定多个队列也是被允许的。在这个案例中，我们要是再给交换机X添加一个绑定到Q1的<code>binding key=black</code>，这样达到的效果就更上篇里面的广播类似了：一个<code>routing key=black</code>的消息过来了，那么Q1，Q2都会收到。  </p><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>综上所述，我们只需要多加一个<code>routing key</code>参数，这样消费者就能够接收到它们希望接受到的消息了。  </p><p>首先，创建一个路由器：  </p><pre><code>channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);</code></pre><p>然后，准备消息的发送：</p><pre><code>channel.basicPublish(EXCHANGE_NAME, severity, null, message.getBytes());</code></pre><p>为了简化，就把<code> severity </code>当做是 ‘info’, ‘warning’, ‘error’这几个级别。  </p><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>消费者代码与之前的就只有一个不同点：需要根据日志的级别<code> severity </code>来来绑定具体的队列。  </p><pre><code>String queueName = channel.queueDeclare().getQueue();for(String severity : argv){      channel.queueBind(queueName, EXCHANGE_NAME, severity);}</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://www.rabbitmq.com/img/tutorials/python-four.png" alt="">  </p><h5 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h5><p><a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/EmitLogDirect.java" target="_blank" rel="noopener">EmitLogDirect.java</a>  </p><pre><code>public class EmitLogDirect {    private static final String EXCHANGE_NAME = &quot;direct_logs&quot;;    public static void main(String[] argv)                  throws java.io.IOException {        ConnectionFactory factory = new ConnectionFactory();        factory.setHost(&quot;localhost&quot;);        Connection connection = factory.newConnection();        Channel channel = connection.createChannel();        channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);        String severity = getSeverity(argv);        String message = getMessage(argv);        channel.basicPublish(EXCHANGE_NAME, severity, null, message.getBytes());        System.out.println(&quot; [x] Sent &apos;&quot; + severity + &quot;&apos;:&apos;&quot; + message + &quot;&apos;&quot;);        channel.close();        connection.close();    }    //..}</code></pre><h5 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h5><p><a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/ReceiveLogsDirect.java" target="_blank" rel="noopener">ReceiveLogsDirect.java</a>  </p><pre><code>import com.rabbitmq.client.*;import java.io.IOException;public class ReceiveLogsDirect {  private static final String EXCHANGE_NAME = &quot;direct_logs&quot;;  public static void main(String[] argv) throws Exception {    ConnectionFactory factory = new ConnectionFactory();    factory.setHost(&quot;localhost&quot;);    Connection connection = factory.newConnection();    Channel channel = connection.createChannel();    channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);    String queueName = channel.queueDeclare().getQueue();    if (argv.length &lt; 1){      System.err.println(&quot;Usage: ReceiveLogsDirect [info] [warning] [error]&quot;);      System.exit(1);    }    for(String severity : argv){      channel.queueBind(queueName, EXCHANGE_NAME, severity);    }    System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);    Consumer consumer = new DefaultConsumer(channel) {      @Override      public void handleDelivery(String consumerTag, Envelope envelope,                                 AMQP.BasicProperties properties, byte[] body) throws IOException {        String message = new String(body, &quot;UTF-8&quot;);        System.out.println(&quot; [x] Received &apos;&quot; + envelope.getRoutingKey() + &quot;&apos;:&apos;&quot; + message + &quot;&apos;&quot;);      }    };    channel.basicConsume(queueName, true, consumer);  }}</code></pre><p><br><br><br>————翁英健</p><p>本文地址：<a href="http://wengyingjian.github.io/2016/01/01/rabbitmq-routing/" target="_blank" rel="noopener">http://wengyingjian.github.io/2016/01/01/rabbitmq-routing/</a></p><p>-End-</p><hr>]]></content>
    
    <summary type="html">
    
      Rabbitmq Routing：路由，更加自由的订阅，而不是所有消息的广播
    
    </summary>
    
      <category term="2018年以前" scheme="http://yoursite.com/categories/2018%E5%B9%B4%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="rabbitmq" scheme="http://yoursite.com/tags/rabbitmq/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
